<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Google JavaScript руководство по стилю</title>
    <link rel="stylesheet" href="javaguide.css" />
    <script src="include/styleguide.js"></script>
    <link rel="shortcut icon" href="https://www.google.com/favicon.ico" />
    <script src="include/jsguide.js"></script>
  </head>
  <body onload="initStyleGuide();">
    <div id="content">
      <h1>Google JavaScript руководство по стилю</h1>
      <h2 id="introduction">1 Введение</h2>
      <p>
        Этот документ содержит <strong>полное</strong> описание стандартов
        Google для исходного кода на языке JavaScript. JavaScript файл считается
        написанным в <em>стиле Google</em> если и только если он придерживается
        правил, описанных в этом документе.
      </p>
      <p>
        Как и другие руководства по стилю программирования, данный документ
        охватывает не только вопрос оформления и форматирования кода, но также
        включает соглашения и стандарты написания кода. Хотя документ
        фокусируется на основных быстроприменимых правилах, которым в компании
        Google следуют повсеместно — здесь также описываются правила и советы,
        которым не следуют следовать (как при ручном, так и при автоматическом
        написании кода).
      </p>
      <h3 id="terminology-notes">1.1 Терминологические примечания</h3>
      <p>В данном документе, если не указано другое:</p>
      <ol>
        <li>
          <p>
            Термин <em>комментарий</em> всегда относится к комментарию
            <em>реализации</em>. Мы не используем фразу
            <em>документирующий комментарий</em>. Для этого мы используем общий
            термин &#8220;JSDoc&#8221;, включая текст, читаемый человеком и
            аннотации, обрабатывающиеся компьютером при помощи
            <code>/** &#8230; */</code>.
          </p>
        </li>
        <li>
          <p>
            Данное руководство по стилю ссылается на терминологию
            <a href="http://tools.ietf.org/html/rfc2119">RFC 2119</a>, когда
            использует фразы "нужно", "не нужно", "не стоит" и "вероятно".
            Термины "отдавайте предпочтение" и "избегайте" используются в смысле
            "стоит" и "не стоит" делать соответственно, но не являются
            обязательными правилами.
          </p>
        </li>
      </ol>
      <p>
        Другие <q>терминологические уточнения</q> будут иногда появляться по
        ходу документа.
      </p>
      <h3 id="guide-notes">1.2 Примечания по руководству</h3>
      <p>
        Примеры кода в этом документе не являются
        <strong>нормативными</strong> (т.е. обязательными). Это значит, что
        примеры в стиле Google могут и не иллюстрировать единственно правильный
        вариант стилизации кода. Форматирование кода в данном файле не должено приниматься в качестве правила.
      </p>
      <h2 id="source-file-basics">2 Основы исходных файлов</h2>
      <h3 id="file-name">2.1 Имя файла</h3>
      <p>
        Имена файлов должны быть в нижнем регистре и могут включать нижнее
        подчеркивание (<code>_</code>) или "тире" (<code>-</code>), но без любой
        другой пунктуации. Придерживайтесь договоренностей, которые используются
        в вашем проекте. Расширения файлов должны быть <code>.js</code>.
      </p>
      <h3 id="file-encoding">2.2 Кодировка файлов UTF-8</h3>
      <p>Кодировка файлов должна быть в <strong>UTF-8</strong>.</p>
      <h3 id="special-characters">2.3 Специальные символы</h3>
      <h4 id="whitespace-characters">2.3.1 Пробельные символы</h4>
      <p>
        Помимо последовательности символов перевода строки, символ
        горизонтального проблела (0х20) из таблицы символов ASCII - единственный
        допустимый символ пробела, который может появляться где-либо в исходном
        коде. Это подразумевает, что:
      </p>
      <ol>
        <li><p>Все другие пробельные символы экранируются.</p></li>
        <li>
          <p>
            Отступ с помощью Tab <strong>не</strong> используется для отступа.
          </p>
        </li>
      </ol>
      <h4 id="special-escape-sequences">
        2.3.2 Специальные экранирующие последовательности
      </h4>
      <p>
        Любые символы, которые требуется экранировать специальными символьными
        последовательностями (<code>\'</code>, <code>\"</code>, <code>\\</code>,
        <code>\b</code>, <code>\f</code>, <code>\n</code>, <code>\r</code>,
        <code>\t</code>, <code>\v</code>) - используют данные последовательности 
        вместо числового экранированния (например, <code>\x0a</code>,
        <code>\u000a</code>, or <code>\u{a}</code>). Устаревшие восьмиричные
        символы экранирования не используются.
      </p>
      <h4 id="non-ascii-characters">2.3.3 Не-ASCII символы</h4>
      <p>
        Для оставшихся не-ASCII символов используется или подходящий символ Unicode
        (например, <code>&#8734;</code>), или эквивалентная hex или Unicode
        последовательность символов (например, <code>\u221e</code>) в
        зависимости от того, что делает код более
        <strong>легко читаемым и более понятным</strong>.
      </p>
      <p>
        Подсказка: при использовании Unicode-символов (или их
        последовательноостей), лучше использовать пояснительный комментарий.
      </p>
      <pre><code class="language-js prettyprint">/* В идеале: код хорошо понятен даже без комментария. */
const units = '&#956;s';

/* Разрешено: но необязательно, так как &#956; - это печатаемый символ. */
const units = '\u03bcs'; // '&#956;s'

/* Хорошо: используется экранирование для непечатаемых символов с комментарием для большей ясности. */
return '\ufeff' + content;  // Добавляется знак "порядка байтов".</code></pre>
      <pre><code class="language-js prettyprint badcode">/* Плохо: читатель не понимает, что это за символ. */
const units = '\u03bcs';</code></pre>
      <p>
        Подсказка: никогда не делайте Ваш код менее читабельным просто из-за
        страха, что некоторые программы могут некорректно обрабатывать не-ASCII
        символы. В случае, если это произойдет - программа будет "сломана" и это
        потребуется исправить (т.е. вы не упустите данный момент).
      </p>
      <h2 id="source-file-structure">3 Структура исходных файлов</h2>
      <p>
        Все новые файлы должны быть или файлом <code>goog.module</code> (файл
        содержащий вызов <code>goog.module</code>), или модулем ECMAScript
        (использует операторы <code>import</code> и <code>export</code>). Файлы
        состоят из следующего (по порядку):
      </p>
      <ol>
        <li>Информация о лицензии или авторских правах, если такие имеются</li>
        <li><code>@fileoverview</code> JSDoc, если имеется</li>
        <li>
          Оператор <code>goog.module</code>, если это
          <code>goog.module</code> файл
        </li>
        <li>ES оператор <code>import</code>, если это ES модуль</li>
        <li>
          Операторы <code>goog.require</code> и <code>goog.requireType</code>
        </li>
        <li>Реализация файла</li>
      </ol>
      <p>
        <strong>Только одна линия</strong> отделяет каждую секуцию кода, за исключением
        отделения реализации файла, которая должна отделяться 1 или 2 пустыми
        линиями.
      </p>
      <h3 id="file-copyright">
        3.1 Информация о лицензии или авторских правах, если имеется.
      </h3>
      <p>
        Если информация о лицензии или авторском праве находится в файле, она
        находится здесь.
      </p>
      <h3 id="file-fileoverview">
        3.2 <code>@fileoverview</code> JSDoc, если имеется
      </h3>
      <p>
        Смотрите <a href="#jsdoc-top-file-level-comments">??</a> о правилах
        форматирования.
      </p>
      <h3 id="file-goog-module">3.3 Оператор <code>goog.module</code></h3>
      <p>
        Все <code>goog.module</code> файлы должны объявлять только одно имя для
        <code>goog.module</code> для одного файла: линии, содержащие объявление
        <code>goog.module</code> не должны разрываться и, следовательно, они
        являются исключением из правила про лимит на 80 символов.
      </p>
      <p>
        Внутренние аргументы goog.module - то, что определяет пространство имен.
        Это имя пакета (идентификатор, который отражает фрагмент структуры
        каталогов, где находится исходный код) и, опционально, главный
        класс\перечисление\интерфейс, который определяет связь со всем модулем.
      </p>
      <p>Пример:</p>
      <pre><code class="language-js prettyprint">goog.module('search.urlHistory.UrlHistoryService');</code></pre>
      <h4 id="naming-hierarchy">3.3.1 Иерархия</h4>
      <p>
        Пространство имен модуля никогда не должны именоваться как прямой
        потомок другого модульного пространства имен.
      </p>
      <p>Не разрешается:</p>
      <pre><code class="language-js prettyprint badcode">goog.module('foo.bar');   // 'foo.bar.qux' было бы неплохоgoog.module('foo.bar.baz');</code></pre>
      <p>
        Иерархия каталогов отражает иерархию пространств имен, поэтому более
        глубокие вложенные дочерние элементы являются подкаталогами родительских
        каталогов верхнего уровня. Обратите внимание, что владельцы
        &#8220;родительских&#8221; групп пространств имен обязательно знают обо
        всех дочерних пространствах имен, поскольку они существуют в одном и том
        же каталоге.
      </p>
      <h4 id="file-declare-legacy-namespace">
        3.3.2 <code>goog.module.declareLegacyNamespace</code>
      </h4>
      <p>
        Оператор <code>goog.module</code> может опционально сдедовать до вызова
        <code>goog.module.declareLegacyNamespace();</code>. Опустите
        <code>goog.module.declareLegacyNamespace()</code>, когда это возможно.
      </p>
      <p>Пример:</p>
      <pre><code class="language-js prettyprint">goog.module('my.test.helpers');goog.module.declareLegacyNamespace();goog.setTestOnly();</code></pre>
      <p>
        <code>goog.module.declareLegacyNamespace</code> существует для
        облегчения перехода от традиционных пространств имен на основе иерархии
        объектов, но имеет некоторые ограничения в плане именования. Поскольку
        имя дочернего модуля должно быть создано после родительского
        пространства имен, это имя <strong>не должно быть</strong> не должно
        быть дочерним или родительским по отношению к
        <code>goog.module</code> (например,
        <code>goog.module('parent');</code> и
        <code>goog.module('parent.child');</code> не могут существовать
        одновременно, также как не может <code>goog.module('parent');</code> и
        <code>goog.module('parent.child.grandchild');</code>).
      </p>
      <h3 id="file-goog-module-exports">
        3.3.3 <code>goog.module</code> Экспорт
      </h3>
      <p>
        Классы, перечисления, функции, константы и другие символы
        экспортируются, используя объект <code>exports</code>. Экспортируемые
        символы могут быть определены прямо в объекте <code>exports</code>, или
        иначе определяться локально и экспортировать раздельно. Символы
        экспортируются только, если они должны использоваться за пределами
        модулям. Не экспортируемые модульно-локальные символы не декларируются
        как <code>@private</code> и не заканчиваются нижней чертой.
        Определенного порядка для экспортируемых модульно-локальных символов -
        нет.
      </p>
      <p>Пример:</p>
      <pre><code class="language-js prettyprint">const /** !Array&lt;number&gt; */ exportedArray = [1, 2, 3];const /** !Array&lt;number&gt; */ moduleLocalArray = [4, 5, 6];/** @return {number} */function moduleLocalFunction() {  return moduleLocalArray.length;}/** @return {number} */function exportedFunction() {  return moduleLocalFunction() * 2;}exports = {exportedArray, exportedFunction};</code></pre>
      <pre><code class="language-js prettyprint">/** @const {number} */exports.CONSTANT_ONE = 1;/** @const {string} */exports.CONSTANT_TWO = 'Другая константа';</code></pre>
      <p>
        Не аннотируйте <code>exports</code> с помощью <code>@const</code>, так
        как они уже рассматриваются компилятором в качестве констант.
      </p>
      <pre><code class="language-js badcode prettyprint">/** @const */exports = {exportedFunction};</code></pre>
      <p><span id="file-es6-modules"></span></p>
      <h3 id="file-es-modules">3.4 ES модули</h3>
      <p><span id="es6-module-imports"></span></p>
      <h4 id="es-module-imports">3.4.1 Импорт</h4>
      <p>
        Операторы импорта не должны разделяться переносом строки и,
        следовательно, являются исключением из ограничения в 80 столбцов.
      </p>
      <p><span id="es6-import-paths"></span></p>
      <h5 id="esm-import-paths">3.4.1.1 Импорт путей</h5>
      <p>
        Файлы ES модуля должны использовать оператор <code>import</code> для
        импорта файлов из ES модуля. Не используйте
        <code>goog.require</code> для другого ES модуля.
      </p>
      <pre><code class="language-js prettyprint external">import './sideeffects.js';import * as goog from '../closure/goog/goog.js';import * as parent from '../parent.js';import {name} from './sibling.js';</code></pre>
      <p><span id="es6-import-paths-file-extension"></span></p>
      <h6 id="esm-import-paths-file-extension">
        3.4.1.1.1 Расширения файлов в для импортируемых путей
      </h6>
      <p>
        Расширение <code>.js</code> не является опциональным в импортируемых
        путях и всегда должно присутствовать.
      </p>
      <pre><code class="language-js badcode prettyprint">import '../directory/file';</code></pre>
      <pre><code class="language-js good prettyprint">import '../directory/file.js';</code></pre>
      <h5 id="importing-the-same-file-multiple-times">
        3.4.1.2 Импорт одного файла несколько раз
      </h5>
      <p>
        Не импортируйте один и тот же файл несколько раз. Это может затруднить
        определение совокупности всех импортов из файла.
      </p>
      <pre><code class="language-js badcode prettyprint">// Импорт имеет один и тот же путь, но, поскольку он не выравнивается, может быть трудно его заметить.import {short} from './long/path/to/a/file.js';import {aLongNameThatBreaksAlignment} from './long/path/to/a/file.js';</code></pre>
      <p><span id="naming-es6-imports"></span></p>
      <h5 id="naming-esm-imports">3.4.1.3 Именование импортов</h5>
      <h6 id="naming-module-imports">
        3.4.1.3.1 Именование модульных импортов
      </h6>
      <p>
        Имена импорта модуля (<code>import * as name</code>) - это имена в
        <code>нижнемВерблюжьемСтиле</code>, которые получены из имени
        импортируемого файла.
      </p>
      <pre><code class="language-js prettyprint">import * as fileOne from '../file-one.js';import * as fileTwo from '../file_two.js';import * as fileThree from '../filethree.js';</code></pre>
      <pre><code class="language-js prettyprint">import * as libString from './lib/string.js';import * as math from './math/math.js';import * as vectorMath from './vector/math.js';</code></pre>
      <h6 id="naming-default-imports">
        3.4.1.3.2 Именование импортов по умолчанию
      </h6>
      <p>
        Имена импорта по умолчанию получены из имени импортируемого файла и
        следуют правилам из <a href="#naming-rules-by-identifier-type">??</a>.
      </p>
      <pre><code class="language-js prettyprint">import MyClass from '../my-class.js';import myFunction from '../my_function.js';import SOME_CONSTANT from '../someconstant.js';</code></pre>
      <p>
        Примечание. В общем случае этого не должно происходить, поскольку
        экспорт по умолчанию запрещен этим руководством по стилю, см.
        <a href="#named-vs-default-exports">??</a>. Импорт по умолчанию
        используется только для импорта модулей, которые не соответствуют этому
        руководству по стилю.
      </p>
      <h6 id="naming-named-imports">
        3.4.1.3.3 Именование именованного импорта
      </h6>
      <p>
        В целом, символы, импортируемые через именованный импорт (<code
          >import {name}</code
        >), должны иметь одинаковое имя. Избегайте импорта псевдонимов (<code
          >import {SomeThing as SomeOtherThing}</code
        >). Отдавайте предпочтение исправлению конфликты имен, при помощи
        использования модуля (<code>import *</code>) или переименовывая сами
        экспорты.
      </p>
      <pre><code class="language-js prettyprint">import * as bigAnimals from './biganimals.js';import * as domesticatedAnimals from './domesticatedanimals.js';new bigAnimals.Cat();new domesticatedAnimals.Cat();</code></pre>
      <p>
        Если необходимо переименовать именованный импорт, используйте компоненты
        имени файла или пути импортированного модуля в полученном псевдониме.
      </p>
      <pre><code class="language-js prettyprint">import {Cat as BigCat} from './biganimals.js';import {Cat as DomesticatedCat} from './domesticatedanimals.js';new BigCat();new DomesticatedCat();</code></pre>
      <p><span id="es6-module-exports"></span></p>
      <h4 id="es-module-exports">3.4.2 Exports</h4>
      <p>
        Символы экспортируются только в том случае, если они предназначены для
        использования вне модуля. Неэкспортированные локальные символы не
        объявляются как <code>@private</code>, и их имена не заканчиваются
        подчеркиванием. Не существует предписанного порядка для экспортируемых и
        локальных символов.
      </p>
      <h5 id="named-vs-default-exports">
        3.4.2.1 Именованные против экспорта по умолчанию
      </h5>
      <p>
        Используйте именованные экспорты во всем коде. Вы можете применить
        ключевое слово <code>export</code> к объявлению или использовать
        синтаксис <code>export {name};</code>.
      </p>
      <p>
        Не используйте экспорт по умолчанию. Импортирующие модули должны давать
        имя этим значениям, чтобы избежать несоответствий в именах модулей.
      </p>
      <pre><code class="language-js badcode prettyprint">// Не используйте эспорт по умолчанию:export default class Foo { ... } // Плохо!</code></pre>
      <pre><code class="language-js good prettyprint">// Используйте именованный экспорт:export class Foo { ... }</code></pre>
      <pre><code class="language-js good prettyprint">// Альтернативный стиль с именем экспорта:class Foo { ... }export {Foo};</code></pre>
      <h5 id="exporting-static-containers">
        3.4.2.2 Экспорт статических контейнерных классов и объектов
      </h5>
      <p>
        Не экспортируйте классы контейнеров или объекты со статическими методами
        или свойствами для пространства имен.
      </p>
      <pre><code class="language-js badcode prettyprint">// container.js// Плохо: контейнер - это экспортируемый класс, который имеет только статические методы и поля.export class Container {  /** @return {number} */  static bar() {    return 1;  }}/** @const {number} */Container.FOO = 1;</code></pre>
      <p>Вместо этого экспортируйте отдельные константы и функции:</p>
      <pre><code class="language-js good prettyprint">/** @return {number} */export function bar() {  return 1;}export const /** number */ FOO = 1;</code></pre>
      <p><span id="es6-exports-mutability"></span></p>
      <h5 id="esm-exports-mutability">3.4.2.3 Мутироемость экспорта</h5>
      <p>
        Экспортируемые переменные не должны быть видоизменены за пределами
        инициализации модуля.
      </p>
      <p>
        Существуют альтернативы, если необходима мутация, включая экспорт
        постоянной ссылки на объект, который имеет изменяемые поля или экспорт
        функций доступа для изменяемых данных.
      </p>
      <pre><code class="language-js badcode prettyprint">// Плохо: и foо, и mutateFoo экспортируются и могут быть изменены.export let /** number */ foo = 0;/** * Изменяется foo. */export function mutateFoo() {  ++foo;}/** * @param {function(number): number} newMutateFoo */export function setMutateFoo(newMutateFoo) {  // Экспортируемые классы и функции могут быть видоизменены!  mutateFoo = () =&gt; {    foo = newMutateFoo(foo);  };}</code></pre>
      <pre><code class="language-js good prettyprint">// Хорошо: вместо того, чтобы экспортировать изменяемые переменные foo и mutateFoo напрямую,// вместо этого сделайте их модульными и экспортируйте getter для foo и оболочку для// mutateFooFunc.let /** number */ foo = 0;let /** function(number): number */ mutateFooFunc = foo =&gt; foo + 1;/** @return {number} */export function getFoo() {  return foo;}export function mutateFoo() {  foo = mutateFooFunc(foo);}/** @param {function(number): number} mutateFoo */export function setMutateFoo(mutateFoo) {  mutateFooFunc = mutateFoo;}</code></pre>
      <p><span id="es6-module-circular-dependencies"></span></p>
      <h5 id="es-module-export-from">3.4.2.4 export from</h5>
      <p>
        Операторы <code>export from</code> не должны быть заключены в строку и
        следовательно, являются исключением из ограничения в 80 символом. Это
        относится ко всем <code>export from</code> операторам.
      </p>
      <pre><code class="language-js">export {specificName} from './other.js';export * from './another.js';</code></pre>
      <h4 id="es-module-circular-dependencies">
        3.4.3 Цикличные зависимости в ES модулях
      </h4>
      <p>
        Не создавайте циклы между модулями ES, даже если спецификация ECMAScript
        позволяет это. Обратите внимание, что можно создавать циклы как с
        помощью операторов <code>import</code>, так и <code>export</code>.
      </p>
      <pre><code class="language-js badcode prettyprint">// a.jsimport './b.js';</code></pre>
      <pre><code class="language-js badcode prettyprint">// b.jsimport './a.js';// `export from` тоже может вызвать цикличиские зависимости!export {x} from './c.js';</code></pre>
      <pre><code class="language-js badcode prettyprint">// c.jsimport './b.js';export let x;</code></pre>
      <p><span id="es6-module-closure-interop"></span></p>
      <h4 id="es-module-closure-interop">3.4.4 Interoperating with Closure</h4>
      <p><span id="es6-module-referencing-goog"></span></p>
      <h5 id="es-module-referencing-goog">3.4.4.1 Ссылание goog</h5>
      <p>
        Для ссылки на пространство имён замыкания <code>goog</code>,
        импортируйте <code>goog.js</code> принадлежащий конкретному замыканию.
      </p>
      <pre><code class="language-js good prettyprint external">import * as goog from '../closure/goog/goog.js';const name = goog.require('a.name');export const CONSTANT = name.compute();</code></pre>
      <p>
        <code>goog.js</code> экспортирует только подмножество параметров из
        глобального <code>goog</code>, которые могут использоваться в ES
        модулях.
      </p>
      <p><span id="goog-require-in-es6-module"></span></p>
      <h5 id="goog-require-in-es-module">3.4.4.2 goog.require в ES модулях</h5>
      <p>
        <code>goog.require</code> в ES модулях работает так же, как и в
        <code>goog.module</code> файлах. Вы можете потребовать (require) любой
        символ пространства имён из замыкания (т.е. символы созданные с помощью
        <code>goog.provide</code> или <code>goog.module</code>) и
        <code>goog.require</code> вернёт значение.
      </p>
      <pre><code class="language-js prettyprint external">import * as goog from '../closure/goog/goog.js';import * as anEsModule from './anEsModule.js';const GoogPromise = goog.require('goog.Promise');const myNamespace = goog.require('my.namespace');</code></pre>
      <p><span id="closure-module-id-in-es6-module"></span></p>
      <h5 id="closure-module-id-in-es-module">
        3.4.4.3 Декларирование ID замыканий в ES модулях
      </h5>
      <p>
        <code>goog.declareModuleId</code> может использоваться в ES модулях,
        чтобы декларировать ID модуля в стиле <code>goog.module</code>. Это
        значит, что ID модуля может быть потребован с помощью
        <code>goog.require</code>, <code>goog.module.get</code>,
        <code>goog.forwardDeclare</code>'d и т.п., как-будто это
        <code>goog.module</code> , который не вызывает
        <code>goog.module.declareLegacyNamespace</code>. Это не создаёт ID для
        модуля в качестве глобально доступного символ JavaScript.
      </p>
      <p>
        <code>goog.require</code> (or <code>goog.module.get</code>) для ID
        модуля из <code>goog.declareModuleId</code> будет всегда возвращать
        объект модуля (как будто используется <code>import *</code>'d). Как
        результат, аргумент для <code>goog.declareModuleId</code> должен всегда
        заканчиваться <code>имяНижнегоРегистра</code>.
      </p>
      <p>
        Обратите внимание: это ошибка - вызывать
        <code>goog.module.declareLegacyNamespace</code> в ES модуле, он может
        быть вызван только из файлов <code>goog.module</code>. Не существует
        прямолинейных путей, чтобы ассоциировать <q>устаревшее</q> пространство
        имён с ES модулем.
      </p>
      <p>
        <code>goog.declareModuleId</code> должен использоваться только, чтобы
        обновить файлы замыканий в месте, где используется именованный экспорт.
      </p>
      <pre><code class="language-js prettyprint external">import * as goog from '../closure/goog.js';goog.declareModuleId('my.esm');export class Class {};</code></pre>
      <h3 id="file-set-test-only">3.5 <code>goog.setTestOnly</code></h3>
      <p>
        В файле модуля <code>goog.module</code> оператор
        <code>goog.module</code> может опционально сопровождаться вызовом
        <code>goog.setTestOnly()</code>.
      </p>
      <p>
        В ES модуле оператор <code>import</code> может опционально
        сопровождаться вызовом <code>goog.setTestOnly()</code>.
      </p>
      <h3 id="file-goog-require">
        3.6 Операторы <code>goog.require</code> и <code>goog.requireType</code>
      </h3>
      <p>
        Импорты реализованные с помощью операторов <code>goog.require</code> и
        <code>goog.requireType</code>. Имена импортированные с помощью оператора
        <code>goog.require</code> могут быть использованы и в коде, и в
        аннотациях, в то время как импортированные с помощью
        <code>goog.requireType</code> могут быть использованные в аннотациях
        типа.
      </p>
      <p>
        Операторы <code>goog.require</code> и
        <code>goog.requireType</code> формируют смежны блок без пустых линий.
        Этот блок следуют за декларацией <code>goog.module</code> разделённой
        <a href="#source-file-structure">с помощью одной пустой линии</a>.
        Единственный аргумент для <code>goog.require</code> или
        <code>goog.requireType</code> - это пространство имен, определенное с
        помощью <code>goog.module</code> в отдельном файле. Операторы
        <code>goog.require</code> и <code>goog.requireType</code> не должны
        появляться в других местах данного файла.
      </p>
      <p>
        Каждый <code>goog.require</code> или
        <code>goog.requireType</code> определяется в единственном константном
        псевдониме или деструктурируется в несколько константных псевдонимах.
        Эти псевдонимы единственные допустимые способы для ссылания на
        зависимости в коде или аннотациях. Полные имена пространства имен не
        должны использоваться нигде, кроме как в качестве аргумента дял
        <code>goog.require</code> или <code>goog.requireType</code>.
      </p>
      <p>
        <strong>Ислючение</strong>: Типы, переменные, и функции определенные во
        внешних файлах вынуждены использовать их полные имена в аннотациях и
        коде.
      </p>
      <p>
        Псевдонимы должны соответствовать финальному компоненту, разделенному
        точками, принаделажщему пространству имен испортируемого модуля.
      </p>
      <p>
        <strong>Исклбючение</strong>: В некоторых случаях, дополнительные
        компоненты пространства имен могут использоваться для формирования более
        длинных псевдонимов. Полученный псевдоним должен сохранять регистр
        исходного идентификатора, чтобы он по-прежнему правильно идентифицировал
        свой тип. Более длинные псевдонимы могут использоваться для устранения
        неоднозначности идентичных псевдонимов, или, если это значительно
        улучшает читабельность. Кроме того, для предотвращения маскирования
        нативных типов, таких как <code>Element</code>, <code>Event</code>,
        <code>Error</code>, <code>Map</code>, и <code>Promise</code> (см. более
        полный список в
        <a
          href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects"
          >Стандартные встроенные объекты</a
        >
        и MDN
        <a href="https://developer.mozilla.org/en-US/docs/Web/API">Web APIs</a>
        ). При переименовании деструктурированных псевдонимов пробел должен
        следовать за двоеточием, как требуется в
        <a href="#formatting-horizontal-whitespace">??</a>.
      </p>
      <p>
        Файл должен содержать операторы <code>goog.require</code> и
        <code>goog.requireType</code> для одного и того же пространства
        имен.Если импортированное имя используется как в коде, так и в
        аннотациях типа, оно должно быть импортировано одним оператором
        <code>goog.require</code>.
      </p>
      <p>
        Если модуль импортируется только для его побочных эффектов, вызов должен
        быть сделан при помощи <code>goog.require</code> (а не
        <code>goog.requireType</code>) и назначение может быть опущено.
        Комментарий необходим, чтобы объяснить, почему это необходимо, и
        подавить предупреждение компилятора.
      </p>
      <p>
        Строки сортируются в соответствии со следующими правилами: Все
        требования с именем слева идут на первом месте, сортируются по алфавиту
        по этим именам. Затем требуется деструктуризация, снова отсортированная
        по именам с левой стороны. Наконец, любые требующие вызовы, которые
        являются автономными (обычно это для модулей, импортированных только для
        их побочных эффектов)
      </p>
      <p>
        Совет. Нет необходимости запоминать этот порядок и применять его
        вручную. Вы можете положиться на свою среду IDE, чтобы сообщить о
        требованиях, которые отсортированы неправильно
      </p>
      <p>
        Если длинный псевдоним или имя модуля приведет к тому, что строка
        превысит ограничение в 80 столбцов, оно <strong>не</strong> должно
        переноситься: обязательные строки являются исключением из ограничения в
        80 столбцов.
      </p>
      <p>Пример:</p>
      <pre><code class="language-js prettyprint">// Стандартный стиль псевдонимов.const MyClass = goog.require('some.package.MyClass');const MyType = goog.requireType('some.package.MyType');// Псевдоним на основе пространства имен, используемый для устранения неоднозначности.const NsMyClass = goog.require('other.ns.MyClass');// Псевдоним на основе пространства имен, используемый для предотвращения маскирования собственного типа.const RendererElement = goog.require('web.renderer.Element');// Вне последовательности псевдонимы на основе пространства имен используются для улучшения читабельности.// Кроме того, строки, содержащие более 80 столбцов, не должны переноситься.const SomeDataStructureModel = goog.requireType('identical.package.identifiers.models.SomeDataStructure');const SomeDataStructureProto = goog.require('proto.identical.package.identifiers.SomeDataStructure');// Стандартный стиль псевдонима.const asserts = goog.require('goog.asserts');// Псевдоним на основе пространства имен, используемый для устранения неоднозначности.const testingAsserts = goog.require('goog.testing.asserts');// Стандартная деструкция в псевдонимы.const {clear, clone} = goog.require('goog.array');const {Rgb} = goog.require('goog.color');// Деструктуризация на основе пространства имен в псевдонимы для устранения неоднозначности.const {SomeType: FooSomeType} = goog.requireType('foo.types');const {clear: objectClear, clone: objectClone} = goog.require('goog.object');// goog.require without an alias in order to trigger side effects./** @suppress {extraRequire} Инициализируется MyFramework. */goog.require('my.framework.initialization');</code></pre>
      <p>Неоднозначно:</p>
      <pre><code class="language-js badcode prettyprint">// Если необходимо устранить неоднозначность, предпочтите PackageClass, а не SomeClass// ближе к формату имени модуля.const SomeClass = goog.require('some.package.Class');</code></pre>
      <p>Запрещено:</p>
      <pre><code class="language-js badcode prettyprint">// Дополнительные термины должны исходить из пространства имен.const MyClassForBizzing = goog.require('some.package.MyClass');// Псевдоним должен включать весь конечный компонент пространства имен.const MyClass = goog.require('some.package.MyClassForBizzing');// Псевдоним не должен маскировать собственный тип (здесь должно быть `const JspbMap`).const Map = goog.require('jspb.Map');// Не ломайте goog.require строки более 80 символов.const SomeDataStructure =    goog.require('proto.identical.package.identifiers.SomeDataStructure');// Псевдоним должен быть основан на пространстве имен.const randomName = goog.require('something.else');// Отсутствует пробел после двоеточия.const {Foo:FooProto} = goog.require('some.package.proto.Foo');// goog.requireType без псевдонима.goog.requireType('some.package.with.a.Type');/** * @param {!some.unimported.Dependency} param Все внешние типы использующиеся в JSDoc *    аннотациях должны быть потребованы с помощью goog.require, если не объявлено в externs. */function someFunction(param) {  // goog.require строки должны быть на верхнем уровне перед любым другим кодом.  const alias = goog.require('my.long.name.alias');  // ...}</code></pre>
      <h3 id="file-implementation">3.7 Реализация файла</h3>
      <p>
        Реальная реализация следует после того, как вся информация о
        зависимостях объявлена (разделена хотя бы одной пустой строкой).
      </p>
      <p>
        Это может состоять из любых локальных объявлений модулей (констант,
        переменных, классов, функций и т. Д.), А также любых экспортируемых
        символов.
      </p>
      <h2 id="formatting">4 Форматирование</h2>
      <p>
        <strong>Терминологическая заметка</strong>:
        <em>блочная конструкция</em> ссылается на тело класса, функции, метода
        или блока кода, разделенного скобками. Обратите внимание, что по
        правилам <a href="#features-array-literals">??</a> и
        <a href="#features-object-literals">??</a>, любой массив или объектный
        литерал может опционально обрабатываться, как если бы это была блочная
        конструкция.
      </p>
      <p>
        Подсказка: Используйте <code>clang-format</code>. Сообщество JavaScript
        приложило усилия, чтобы убедиться, clang-format
        <q>правильно работает</q> в JavaScript файлах.
        <code>clang-format</code> имеет интеграцию с несколькими популярными
        редакторами.
      </p>
      <h3 id="formatting-braces">4.1 Скобки</h3>
      <h4 id="formatting-braces-all">
        4.1.1 Скобки, использующиеся для всех управляющих структур
      </h4>
      <p>
        Скобки требуются для всех управляющих структур (например,
        <code>if</code>, <code>else</code>, <code>for</code>, <code>do</code>,
        <code>while</code> и т.п.), даже если тело содержит один оператор.
        Первый оператор непустого блока должен начинаться с отдельной строки.
      </p>
      <p>Не разрешено:</p>
      <pre><code class="language-js badcode prettyprint">if (someVeryLongCondition())  doSomething();for (let i = 0; i &lt; foo.length; i++) bar(foo[i]);</code></pre>
      <p>
        <strong>Исключение</strong>: Простой оператор if, который может
        поместиться целиком в одну строку без переноса (и в котором нет
        другого), может быть сохранен в одной строке без фигурных скобок, когда
        он улучшает читабельность. Это единственный случай, когда управляющая
        структура может пропускать скобки и переводы строк.
      </p>
      <pre><code class="language-js prettyprint">if (shortCondition()) foo();</code></pre>
      <h4 id="formatting-nonempty-blocks">
        4.1.2 Непустые блоки: стиль K&amp;R
      </h4>
      <p>
        Скобки следуют стилю Кернигана и Ричи (<q
          ><a
            href="http://www.codinghorror.com/blog/2012/07/new-programming-jargon.html"
            >египитские скобки</a
          ></q
        >) для <em>непутсых</em> блоков и блочных конструкций:
      </p>
      <ul>
        <li>Никакого разрыва строки перед открывающей скобкой.</li>
        <li>Разрыв строки после открывающей скобки.</li>
        <li>Разрыв строки перед закрывающей скобкой.</li>
        <li>
          Разрыв строки после закрывающей скобки <em>if</em> эта фигурная скобка
          завершает оператор или тело оператора функции или класса или метод
          класса. В частности, после фигурной скобки <em>нет</em> разрыва
          строки, если за ней следует <code>else</code>, <code>catch</code>,
          <code>while</code>, или запятая, точка с запятой или правая скобка.
        </li>
      </ul>
      <p>Пример:</p>
      <pre><code class="language-js prettyprint">class InnerClass {  constructor() {}  /** @param {number} foo */  method(foo) {    if (condition(foo)) {      try {        // Обратите внимание: это может потерпеть неудачу.        something();      } catch (err) {        recover();      }    }  }}</code></pre>
      <h4 id="formatting-empty-blocks">
        4.1.3 Пустые блоки: могут быть краткими
      </h4>
      <p>
        Пустой блок или блочно-подобная конструкция <em>может</em> быть закрыта
        сразу после открытия, без символов, пробелов или разрыва строки между
        ними (например, <code>{}</code>), <strong>Если</strong> только это не
        является частью <em>многоблочного оператора</em> (который содержит
        непосредственно несколько блоков: <code>if</code>/<code>else</code> или
        <code>try</code>/<code>catch</code>/<code>finally</code>).
      </p>
      <p>Пример:</p>
      <pre><code class="language-js prettyprint">function doNothing() {}</code></pre>
      <p>Запрещено:</p>
      <pre><code class="language-js prettyprint badcode">if (condition) {  // &#8230;} else if (otherCondition) {} else {  // &#8230;}try {  // &#8230;} catch (e) {}</code></pre>
      <h3 id="formatting-block-indentation">4.2 Блочный отступ: +2 пробела</h3>
      <p>
        Каждый раз, когда открывается новый блок или блочная конструкция, отступ
        увеличивается на два пробела. Когда блок заканчивается, отступ
        возвращается к предыдущему уровню отступа. Уровень отступа применяется
        как к коду, так и к комментариям по всему блоку. (См. Пример в
        <a href="#formatting-nonempty-blocks">??</a>).
      </p>
      <h4 id="formatting-array-literals">
        4.2.1 Литералы массива: <q>опционально блочные</q>
      </h4>
      <p>
        Любой литерал массива может быть необязательно отформатирован так, как
        если бы он был «блочной конструкцией». Например, допустимые варианты
        ниже (<strong>не</strong> исчерпывающий список):
      </p>
      <pre><code class="language-js prettyprint columns">const a = [  0,  1,  2,];const b =    [0, 1, 2];</code></pre>
      <pre><code class="language-js prettyprint columns">const c = [0, 1, 2];someMethod(foo, [  0, 1, 2,], bar);</code></pre>
      <p>
        Допускаются другие комбинации, особенно при выделении семантических
        группировок между элементами, но они не должны использоваться только для
        уменьшения вертикального размера больших массивов.
      </p>
      <h4 id="formatting-object-literals">
        4.2.2 Объектные литералы: <q>опционально блочные</q>
      </h4>
      <p>
        Любой объектный литерал может быть отформатирован так, как если бы он
        был «блочной конструкцией». Применяются те же примеры, что и
        <a href="#formatting-array-literals">??</a>. Например, следующие
        действительны (<strong>не</strong> исчерпывающий список):
      </p>
      <pre><code class="language-js prettyprint columns">const a = {  a: 0,  b: 1,};const b =    {a: 0, b: 1};</code></pre>
      <pre><code class="language-js prettyprint columns">const c = {a: 0, b: 1};someMethod(foo, {  a: 0, b: 1,}, bar);</code></pre>
      <h4 id="formatting-class-literals">4.2.3 Литералы класса</h4>
      <p>
        Литералы класса (будь то объявления или выражения) имеют отступ в виде
        блоков. Не добавляйте точку с запятой после методов или после
        закрывающей скобки <em>объявления класса</em> (операторы, такие как
        присваивания, которые содержат <em>выражения</em> класса, по-прежнему
        заканчиваются точкой с запятой). Используйте ключевое слово
        <code>@extends</code>, но не аннотацию <code>@extends</code> JSDoc, если
        класс не расширяет шаблонизированный тип.
      </p>
      <p>Пример:</p>
      <pre><code class="language-js prettyprint columns">class Foo {  constructor() {    /** @type {number} */    this.x = 42;  }  /** @return {number} */  method() {    return this.x;  }}Foo.Empty = class {};</code></pre>
      <pre><code class="language-js prettyprint columns">/** @extends {Foo&lt;string&gt;} */foo.Bar = class extends Foo {  /** @override */  method() {    return super.method() / 2;  }};/** @interface */class Frobnicator {  /** @param {string} message */  frobnicate(message) {}}</code></pre>
      <h4 id="formatting-function-expressions">
        4.2.4 Функциональные выражения
      </h4>
      <p>
        При объявлении анонимной функции в списке аргументов для вызова функции
        тело функции имеет отступ на два пробела больше, чем предыдущая глубина
        отступа.
      </p>
      <p>Пример:</p>
      <pre><code class="language-js prettyprint">prefix.something.reallyLongFunctionName('whatever', (a1, a2) =&gt; {  // Отступ тела функции +2 относительно глубины отступа  // оператора "префикса" на одну строку выше.  if (a1.equals(a2)) {    someOtherLongFunctionName(a1);  } else {    andNowForSomethingCompletelyDifferent(a2.parrot);  }});some.reallyLongFunctionCall(arg1, arg2, arg3)    .thatsWrapped()    .then((result) =&gt; {      // Отступ тела функции +2 относительно глубины отступа      // от вызова '.then()'.      if (result) {        result.use();      }    });</code></pre>
      <h4 id="formatting-switch-statements">4.2.5 Switch оператор</h4>
      <p>
        Как и в любом другом блоке, содержимое блока switch имеет отступ +2.
      </p>
      <p>
        После метки переключателя появляется новая строка, и уровень отступа
        увеличивается на +2, точно так же, как если бы блок открывался. Явный
        блок может использоваться, если этого требует лексическая область
        видимости. Следующая метка переключателя возвращает к предыдущему уровню
        отступа, как если бы блок был закрыт.
      </p>
      <p>
        Пустая строка необязательна между <code>break</code> и следующим
        случаем.
      </p>
      <p>Пример:</p>
      <pre><code class="language-js prettyprint">switch (animal) {  case Animal.BANDERSNATCH:    handleBandersnatch();    break;  case Animal.JABBERWOCK:    handleJabberwock();    break;  default:    throw new Error('Unknown animal');}</code></pre>
      <h3 id="formatting-statements">4.3 Операторы</h3>
      <h4 id="formatting-one-statement-perline">
        4.3.1 Один оператор на строку
      </h4>
      <p>После каждого оператора делается перевод строки.</p>
      <h4 id="formatting-semicolons-are-required">
        4.3.2 Необходима точка с запятой.
      </h4>
      <p>
        Каждое утверждение должно заканчиваться точкой с запятой. Использование
        автоматической точки с запятой запрещено.
      </p>
      <h3 id="formatting-column-limit">4.4 Лимит строки: 80 символов</h3>
      <p>
        Код JavaScript имеет ограничение столбца 80 символов. За исключением
        случаев, указанных ниже, любая строка, которая превысила бы этот предел,
        должна быть перенесена, как описано в
        <a href="#formatting-line-wrapping">??</a>.
      </p>
      <p><strong>Исключения:</strong></p>
      <ol>
        <li>
          Операторы <code>goog.module</code>, <code>goog.require</code> и
          <code>goog.requireType</code> (см.
          <a href="#file-goog-module">??</a> и
          <a href="#file-goog-require">??</a>).
        </li>
        <li>
          ES модули <code>import</code> и операторы
          <code>export from</code> (см. <a href="#es-module-imports">??</a> и
          <a href="#es-module-export-from">??</a>).
        </li>
        <li>
          Линии, в которых соблюдение предела столбцов невозможно или может
          препятствовать обнаружению. Примеры включают в себя:
          <ul>
            <li>Длинный URL, который должен быть кликабельным в источнике.</li>
            <li>Команда консоли, предназначенная для копирования и вставки</li>
            <li>
              Длинный строковый литерал, который может потребоваться полностью
              скопировать или найти (например, длинный путь к файлу).
            </li>
          </ul>
        </li>
      </ol>
      <h3 id="formatting-line-wrapping">4.5 Перенос строк</h3>
      <p>
        <strong>Терминологическая заметка</strong>:
        <em>Перенос строки</em> разбивает кусок кода на несколько строк в
        соответствии с ограничением столбца, где фрагмент в противном случае мог
        бы по закону поместиться в одну строку.
      </p>
      <p>
        Не существует всеобъемлющей формулы, показывающей, как
        <em>именно</em> переносить строки в каждой ситуации. Очень часто есть
        несколько допустимых способов переноса строк в одном и том же фрагменте
        кода.
      </p>
      <p>
        Примечание. Хотя типичная причина переноса строки заключается в том,
        чтобы избежать переполнения предела столбца, даже код, который на самом
        деле помещается в пределе столбца, может быть перенесен строкой на
        усмотрение автора.
      </p>
      <p>
        Совет: извлечение метода или локальной переменной может решить проблему
        без необходимости переноса строки.
      </p>
      <h4 id="formatting-where-to-break">4.5.1 Когда переносить</h4>
      <p>
        Основная директива переноса строк такова: предпочитайте разрывать на
        <strong>более высоком синтаксическом уровне</strong>.
      </p>
      <p>Предпочтительно:</p>
      <pre><code class="language-js prettyprint">currentEstimate =    calc(currentEstimate + x * currentEstimate) /        2.0;</code></pre>
      <p>Нежелательно:</p>
      <pre><code class="language-js prettyprint badcode">currentEstimate = calc(currentEstimate + x *    currentEstimate) / 2.0;</code></pre>
      <p>
        В предыдущем примере синтаксические уровни от самого высокого до самого
        низкого следующие: назначение, деление, вызов функции, параметры,
        числовая константа.
      </p>
      <p>Операторы переносятся следующим образом:</p>
      <ol>
        <li>
          Когда у оператора разрывается строка, разрыв следует за символом.
          (Обратите внимание, что это не та же практика, что и в стиле Google
          для Java.)
          <ol>
            <li>
              Это не относится к <q>точке</q> (<code>.</code>), которая на самом
              деле не является оператором.
            </li>
          </ol>
        </li>
        <li>
          Имя метода или конструктора остается присоединенным к открытой круглой
          скобке (<code>(</code>), которая следует за ней.
        </li>
        <li>
          Запятая (<code>,</code>) остается прикрепленной к токену, который
          предшествует ей.
        </li>
      </ol>
      <blockquote>
        <p>
          Примечание. Основной целью переноса строк является наличие четкого
          кода, а не обязательно кода, который помещается в наименьшее
          количество строк.
        </p>
      </blockquote>
      <h4 id="formatting-indent">
        4.5.2 Отступ строки продолжения не менее +4 пробелов
      </h4>
      <p>
        При переносе строк каждая строка после первой (каждая
        <em> строка продолжения </em>) имеет отступ не менее +4 от исходной
        строки, если только она не подпадает под правила отступа блока.
      </p>
      <p>
        Когда имеется несколько строк продолжения, отступ может изменяться за
        пределы +4 в зависимости от ситуации. Как правило, строки продолжения на
        более глубоком синтаксическом уровне имеют отступ с большим числом,
        кратным 4, и две строки используют один и тот же уровень отступа, если и
        только если они начинаются с синтаксически параллельных элементов.
      </p>
      <p>
        <a href="#formatting-horizontal-alignment">??</a> объясняет
        нежелательную практику использования переменного числа пробелов для
        выравнивания определенных токенов с предыдущими строками.
      </p>
      <h3 id="formatting-whitespace">4.6 Пробелы</h3>
      <h4 id="formatting-vertical-whitespace">4.6.1 Вертикальный пробел</h4>
      <p>Одна пустая строка ставится:</p>
      <ol>
        <li>
          Между последовательными методами в литерале класса или объекта
          <ol>
            <li>
              Исключение: пустая строка между двумя последовательными
              определениями свойств в литерале объекта (без другого кода между
              ними) является необязательной. Такие пустые строки используются по
              мере необходимости для создания
              <em>логических группировок</em> полей.
            </li>
          </ol>
        </li>
        <li>
          Внутри тел методов, экономно создавать
          <em>логические группировки</em> операторов. Пустые строки в начале или
          конце тела функции не допускаются.
        </li>
        <li>
          <em>Необязательно</em> перед первым или после последнего метода в
          литерале класса или объекта (не рекомендуется и не поощряется).
        </li>
        <li>
          As required by other sections of this document (e.g.
          <a href="#file-goog-require">??</a>).
        </li>
      </ol>
      <p>
        <em> Несколько </em> последовательных пустых строк разрешены, но никогда
        не требуются (и не поощряются).
      </p>
      <h4 id="formatting-horizontal-whitespace">
        4.6.2 Горизонтальный проблел
      </h4>
      <p>
        Использование горизонтального пробела зависит от местоположения и
        подразделяется на три широкие категории: <em> ведущий </em> (в начале
        строки), <em> конечный </em> (в конце строки) и <em> внутренний </em>.
        ведущий   пробел (то есть отступ) адресован в другом месте. Конечный
        пробел запрещен.
      </p>
      <p>
        Кроме того, где этого требуют правила языка или других стилевых правил,
        а также литералы, комментарии и JSDoc, единое внутреннее пространство
        ASCII также появляется <strong>только</strong> в следующих местах.
      </p>
      <ol>
        <li>
          Отделение любого зарезервированного слова (например, <code>if</code>,
          <code>for</code> или <code>catch</code>), за исключением
          <code>function</code> и <code>super</code> из открытой скобки
          (<code>(</code>), которая следует за ней в этой строке.
        </li>
        <li>
          Отделение любого зарезервированного слова (такого как
          <code>else</code> или <code>catch</code>) от закрывающей фигурной
          скобки (<code>}</code>), которая предшествует ему в этой строке.
        </li>
        <li>
          Перед любой открытой фигурной скобкой (<code>{</code>), с двумя
          исключениями:
          <ol>
            <li>
              Перед литералом объекта, который является первым аргументом
              функции или первым элементом в литерале массива (например,
              <code> foo ({a: [{c: d}]}) </code>).
            </li>
            <li>
              В расширении шаблона, как это запрещено языком (например, валидно:
              <code>`ab${1 + 2}cd`</code>, не валидно:
              <code class="badcode">`xy$ {3}z`</code>).
            </li>
          </ol>
        </li>
        <li>С обеих сторон любой бинарный или троичный оператор.</li>
        <li>
          После запятой (<code>, </code>) или точки с запятой (<code>;</code>).
          Обратите внимание, что пробелы <em>никогда</em> разрешены перед этими
          символами.
        </li>
        <li>После двоеточия (<code>: </code>) в литерале объекта.</li>
        <li>
          По обе стороны от двойной косой черты (<code>//</code>), начинающей
          комментарий в конце строки. Здесь разрешено использование нескольких
          пробелов, но это не обязательно.
        </li>
        <li>
          После символа комментария открытого блока и с обеих сторон символов
          закрытия (например, для кратких объявлений типов, приведений и
          комментариев имени параметра:
          <code>this.foo = /** @type {number} */ (bar)</code>; или
          <code>function(/** string */ foo) {</code>; или
          <code>baz(/* buzz= */ true)</code>).
        </li>
      </ol>
      <h4 id="formatting-horizontal-alignment">
        4.6.3 Горизонтальное выравнивание: не рекомендуется
      </h4>
      <p>
        <strong>Примечание по терминологии:</strong> Горизонтальное выравнивание
        - это практика добавления в ваш код переменного числа дополнительных
        пробелов с целью отображения определенных токенов непосредственно под
        некоторыми другими токенами в предыдущих строках.
      </p>
      <p>
        Эта практика разрешена, но, как правило,
        <strong>не рекомендуется</strong> в Google Style. Даже не требуется
        <em>поддерживать</em> горизонтальное выравнивание в местах, где оно уже
        использовалось.
      </p>
      <p>
        Вот пример без выравнивания, за которым следует пример с выравниванием.
        Оба разрешены, но последний не рекомендуется:
      </p>
      <pre><code class="language-js prettyprint">{  tiny: 42, // хорошо  longer: 435, // тоже хорошо};{  tiny:   42,  // разрешено, но требует будущего редактирования  longer: 435, // может остаться без выравнивания};</code></pre>
      <p>
        Совет: Выравнивание может улучшить читаемость, но создает проблемы для
        дальнейшего обслуживания. Рассмотрим будущее изменение, которое должно
        касаться только одной строки. Это изменение может оставить искаженное
        ранее приятное форматирование, и это разрешено. Чаще всего это побуждает
        кодера (возможно, вас) также корректировать пробелы на близлежащих
        линиях, возможно, вызывая каскадную серию переформатирований. Это
        изменение в одну строку теперь имеет радиус взрыва. В худшем случае это
        может привести к бессмысленной занятой работе, но в лучшем случае это
        все еще искажает информацию об истории версий, замедляет работу
        рецензентов и усугубляет конфликты слияний.
      </p>
      <h4 id="formatting-function-arguments">4.6.4 Аргументы функций</h4>
      <p>
        Предпочитаю помещать все аргументы функции в одну строку с именем
        функции. Если это превысит ограничение в 80 столбцов, аргументы должны
        быть обернуты строкой в удобочитаемом виде. Чтобы сэкономить место, вы
        можете обернуть как можно ближе к 80 или поместить каждый аргумент в
        отдельной строке, чтобы улучшить читаемость. Отступы должны быть четыре
        пробела. Выравнивание в скобках разрешено, но не рекомендуется. Ниже
        приведены наиболее распространенные шаблоны для переноса аргументов:
      </p>
      <pre><code class="language-js prettyprint">// Аргументы начинаются с новой строки, с отступом в четыре пробела. Предпочтительнее, когда// аргументы не помещаются в одну строку с именем функции (или ключевым словом// "функция"), но помещается полностью на второй строке. Работает с очень долго// имена функций, сохраняется переименование без переиндексации, мало места.doSomething(    descriptiveArgumentOne, descriptiveArgumentTwo, descriptiveArgumentThree) {  // &#8230;}// Если список аргументов длиннее, оберните в 80. Использует меньше вертикального пространства,// но нарушает правило прямоугольника и поэтому не рекомендуется.doSomething(veryDescriptiveArgumentNumberOne, veryDescriptiveArgumentTwo,    tableModelEventHandlerProxy, artichokeDescriptorAdapterIterator) {  // &#8230;}// Четыре пробела, один аргумент в строке. Работает с длинными именами функций,// выживает переименование, и подчеркивает каждый аргумент.doSomething(    veryDescriptiveArgumentNumberOne,    veryDescriptiveArgumentTwo,    tableModelEventHandlerProxy,    artichokeDescriptorAdapterIterator) {  // &#8230;}</code></pre>
      <h3 id="formatting-grouping-parentheses">
        4.7 Grouping parentheses: recommended
      </h3>
      <p>
        Необязательные групповые скобки опускаются только в том случае, если
        автор и рецензент согласны с тем, что без них нет никакой разумной
        вероятности, что код будет неверно истолкован, и что они не сделали бы
        код более удобным для чтения. Разумно предположить, что каждый читатель
        запомнил всю таблицу старшинства оператора, а не <em>not</em>.
      </p>
      <p>
        Не используйте лишние скобки вокруг всего выражения после
        <code>delete</code>, <code>typeof</code>, <code>void</code>,
        <code>return</code>, <code>throw</code>, <code>case</code>,
        <code>in</code>, <code>of</code>, или <code>yield</code>.
      </p>
      <p>
        Круглые скобки необходимы для каста типов:
        <code>/** @тип {!Foo}. */(foo)</code>.
      </p>
      <h3 id="formatting-comments">4.8 Comments</h3>
      <p>
        В этом разделе рассматриваются <em>комментарии выполнения</em>. JSDoc
        адресуется отдельно в <a href="#jsdoc">?</a>.
      </p>
      <h4 id="formatting-block-comment-style">4.8.1 Block comment style</h4>
      <p>
        Комментарии блока снабжены отступом на том же уровне, что и окружающий
        код. Они могут быть в стиле <code>/* &#8230; */</code> или
        <code>//</code>. Для многострочных комментариев
        <code>/* &#8230; */</code> последующие строки должны начинаться с *,
        выровненного с <code>*</code> на предыдущей строке, чтобы комментарии
        были очевидны без лишнего контекста.
      </p>
      <pre><code class="language-js prettyprint">/* * This is * okay. */// And so// is this./* This is fine, too. */</code></pre>
      <p>
        Комментарии не вставляются в поля, отрисованные звездочками или другими
        символами.
      </p>
      <p>
        Не используйте JSDoc (<code>/** &#8230; */</code>) для комментариев к
        реализации.
      </p>
      <h4 id="formatting-param-name-comments">4.8.2 Parameter Name Comments</h4>
      <p>
        &#8220; Имя параметра &#8221; комментарии следует использовать во всех
        случаях, когда значение и имя метода не передают в достаточной степени
        смысл, а рефакторинг метода для большей ясности невозможен.
        Предпочтительный для них формат - перед значением с <q>=</q>:
      </p>
      <pre><code class="language-js prettyprint">someFunction(obviousParam, /* shouldRender= */ true, /* name= */ 'hello');</code></pre>
      <p>
        Для согласованности с окружающим кодом можно поместить их после значения
        без <q>=</q>:
      </p>
      <pre><code class="language-js prettyprint">someFunction(obviousParam, true /* shouldRender */, 'hello' /* name */);</code></pre>
      <h2 id="language-features">5 Language features</h2>
      <p>
        JavaScript включает в себя множество сомнительных (и даже опасных)
        возможностей. В этом разделе описывается, какие функции могут
        использоваться, а какие нет, и какие дополнительные ограничения на их
        использование.
      </p>
      <h3 id="features-local-variable-declarations">
        5.1 Local variable declarations
      </h3>
      <h4 id="features-use-const-and-let">
        5.1.1 Use <code>const</code> and <code>let</code>
      </h4>
      <p>
        Объявляйте все локальные переменные либо с помощью <code>const</code>,
        либо с помощью <code>let</code>. Используйте const по умолчанию, если
        только переменная не нуждается в переназначении. Ключевое слово
        <code class="badcode">var</code> не должно использоваться.
      </p>
      <h4 id="features-one-variable-per-declaration">
        5.1.2 One variable per declaration
      </h4>
      <p>
        Каждая декларация локальной переменной объявляет только одну переменную:
        декларации типа <code class="badcode">let a = 1, b = 2;</code> не
        используются.
      </p>
      <h4 id="features-declared-when-needed">
        5.1.3 Declared when needed, initialized as soon as possible
      </h4>
      <p>
        Локальные переменные <strong>not</strong> обычно объявляются в начале их
        содержащей блочной или блокоподобной конструкции. Вместо этого локальные
        переменные объявляются близко к точке, в которой они были впервые
        использованы (в пределах разумного), чтобы минимизировать их охват.
      </p>
      <h4 id="features-declare-types-as-needed">
        5.1.4 Declare types as needed
      </h4>
      <p>
        Аннотации типа JSDoc могут быть добавлены либо в строке над объявлением,
        либо в строке перед именем переменной, если нет других JSDoc.
      </p>
      <p>Пример:</p>
      <pre><code class="language-js prettyprint">const /** !Array&lt;number&gt; */ data = [];/** * Some description. * @type {!Array&lt;number&gt;} */const data = [];</code></pre>
      <p>
        Смешивание inline и JSDoc стилей не допускается: компилятор будет
        обрабатывать только первые JsDoc и аннотации inline будут потеряны.
      </p>
      <pre><code class="language-js prettyprint badcode">/** Some description. */const /** !Array&lt;number&gt; */ data = [];</code></pre>
      <p>
        Подсказка: Существует множество случаев, когда компилятор может сделать
        вывод о соблазнительном типе, но не о его параметрах. В частности, это
        происходит, когда инициализирующий вызов литерала или конструктора не
        включает в себя никаких значений типа параметра шаблона (например,
        пустые массивы, объекты, <code>Map</code>s, или <code>Set</code>s), или
        если переменная изменяется при закрытии. Особенно полезны в этих случаях
        аннотации к типам локальных переменных, так как в противном случае
        компилятор выдаст параметр шаблона за неизвестный.
      </p>
      <h3 id="features-array-literals">5.2 Array literals</h3>
      <h4 id="features-arrays-trailing-comma">5.2.1 Use trailing commas</h4>
      <p>
        Включайте запятую трейлинга всякий раз, когда происходит разрыв строки
        между конечным элементом и закрывающей скобкой.
      </p>
      <p>Пример:</p>
      <pre><code class="language-js prettyprint">const values = [  'first value',  'second value',];</code></pre>
      <h4 id="features-arrays-ctor">
        5.2.2 Do not use the variadic <code>Array</code> constructor
      </h4>
      <p>
        Конструктор подвержен ошибкам при добавлении или удалении аргументов.
        Вместо этого используйте литерал.
      </p>
      <p>Запрещено:</p>
      <pre><code class="language-js prettyprint badcode">const a1 = new Array(x1, x2, x3);const a2 = new Array(x1, x2);const a3 = new Array(x1);const a4 = new Array();</code></pre>
      <p>
        Это работает, как и ожидалось, за исключением третьего случая: если
        <code>x1</code> целое число, то <code>a3</code> - массив размером
        <code>x1</code>, где все элементы <code>неопределены</code>. Если
        <code>x1</code> - любое другое число, то будет брошено исключение, а
        если это что-то другое, то это будет одноэлементный массив.
      </p>
      <p>Вместо этого запишите</p>
      <pre><code class="language-js prettyprint">const a1 = [x1, x2, x3];const a2 = [x1, x2];const a3 = [x1];const a4 = [];</code></pre>
      <p>
        Явное выделение массива заданной длины с помощью
        <code>new Array(length)</code> разрешено, когда это необходимо.
      </p>
      <h4 id="features-arrays-non-numeric-properties">
        5.2.3 Non-numeric properties
      </h4>
      <p>
        Не определяйте и не используйте нецифровые свойства массива (кроме
        <code>length</code>). Вместо этого используйте <code>Map</code> (или
        <code>Object</code>).
      </p>
      <h4 id="features-arrays-destructuring">5.2.4 Destructuring</h4>
      <p>
        Для выполнения деструкции (например, при распаковке нескольких значений
        из одного массива или итерабельных) можно использовать массивные
        литералы слева от задания. Заключительный элемент <q>rest</q> может быть
        включен (без пробела между <code>...</code> и именем переменной).
        Элементы должны быть опущены, если они не используются.
      </p>
      <pre><code class="language-js prettyprint">const [a, b, c, ...rest] = generateResults();let [, b,, d] = someArray;</code></pre>
      <p>
        Деструктуризация также может быть использована для параметров функции
        (обратите внимание, что имя параметра требуется, но игнорируется).
        Всегда указывайте <code>[]</code> в качестве значения по умолчанию, если
        параметр разрушенного массива является необязательным, а также
        указывайте значения по умолчанию с левой стороны:
      </p>
      <pre><code class="language-js prettyprint">/** @param {!Array&lt;number&gt;=} param1 */function optionalDestructuring([a = 4, b = 2] = []) { &#8230; };</code></pre>
      <p>Запрещено:</p>
      <pre><code class="language-js prettyprint badcode">function badDestructuring([a, b] = [4, 2]) { &#8230; };</code></pre>
      <p>
        Совет: Для (un)упаковки нескольких значений в параметр функции&#8217;s
        или return, предпочитайте, когда это возможно, деструкцию объекта, а не
        массива, так как это позволяет именовать отдельные элементы и указывать
        для каждого из них свой тип.
      </p>
      <h4 id="features-arrays-spread-operator">5.2.5 Spread operator</h4>
      <p>
        Литералы массива могут включать оператор spread (<code>...</code>) для
        выравнивания элементов из одного или нескольких итерабелей. Оператор
        spread следует использовать вместо более неудобных конструкций с
        <code>Array.prototype</code>. Пробел после <code>...</code> отсутствует.
      </p>
      <p>Пример:</p>
      <pre><code class="language-js prettyprint">[...foo]   // preferred over Array.prototype.slice.call(foo)[...foo, ...bar]   // preferred over foo.concat(bar)</code></pre>
      <h3 id="features-object-literals">5.3 Object literals</h3>
      <h4 id="features-objects-use-trailing-comma">
        5.3.1 Use trailing commas
      </h4>
      <p>
        Включите трейлинговую запятую всякий раз, когда есть разрыв строки между
        конечным свойством и закрывающей скобкой.
      </p>
      <h4 id="features-objects-ctor">
        5.3.2 Do not use the <code>Object</code> constructor
      </h4>
      <p>
        Хотя <code>Object</code> не имеет тех же проблем, что и
        <code>Array</code>, для согласованности он все равно запрещен. Вместо
        этого используйте объект literal (<code>{}</code> или
        <code>{a: 0, b: 1, c: 2}</code>).
      </p>
      <h4 id="features-objects-mixing-keys">
        5.3.3 Do not mix quoted and unquoted keys
      </h4>
      <p>
        Объектные литералы могут представлять либо <em>инструкции</em> (с
        нецитируемыми ключами и/или символами), либо <em>дикты</em> (с
        цитируемыми и/или вычисленными ключами). Не смешивайте эти типы ключей в
        одном объектном литерале.
      </p>
      <p>Запрещено:</p>
      <pre><code class="language-js prettyprint badcode">{  width: 42, // struct-style unquoted key  'maxWidth': 43, // dict-style quoted key}</code></pre>
      <p>
        Это также распространяется на передачу имени свойства функциям, таким
        как <code>hasOwnProperty</code>. В частности, это нарушит
        скомпилированный код, так как компилятор не может
        переименовать/обмускулировать строковый литерал.
      </p>
      <p>Запрещено:</p>
      <pre><code class="language-js prettyprint badcode">/** @type {{width: number, maxWidth: (number|undefined)}} */const o = {width: 42};if (o.hasOwnProperty('maxWidth')) {  ...}</code></pre>
      <p>Лучше всего это реализовать как:</p>
      <pre><code class="language-js prettyprint">/** @type {{width: number, maxWidth: (number|undefined)}} */const o = {width: 42};if (o.maxWidth != null) {  ...}</code></pre>
      <h4 id="features-objects-computed-property-names">
        5.3.4 Computed property names
      </h4>
      <p>
        Вычисленные имена свойств (например, <code>{['key' + foo()]: 42}</code>)
        разрешены и считаются ключами в десятичном (цитируемом) стиле (т.е. не
        должны смешиваться с нецитируемыми ключами), если только вычисленное
        свойство не является
        <a
          href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol"
          >символ</a
        >
        (например, <code>[Symbol.iterator]</code>). Значения Enum также могут
        быть использованы для вычисляемых ключей, но не должны смешиваться с
        не-знаковыми ключами в одном и том же литерале.
      </p>
      <h4 id="features-objects-method-shorthand">5.3.5 Method shorthand</h4>
      <p>
        Методы могут быть определены на объектных литералах с помощью сокращения
        метода (<code>{method() {&#8230; }}</code>) вместо двоеточия сразу за
        которым следует <code>функция</code> или literal функции стрелки.
      </p>
      <p>Пример:</p>
      <pre><code class="language-js prettyprint">return {  stuff: 'candy',  method() {    return this.stuff;  // Returns 'candy'  },};</code></pre>
      <p>
        Обратите внимание, что <code>-это</code> в сокращении метода или
        <code>функция</code> ссылается на сам объект literal, в то время как
        <code>-это</code> в функции со стрелкой ссылается на область видимости,
        выходящую за рамки объекта literal.
      </p>
      <p>Пример:</p>
      <pre><code class="language-js prettyprint">class {  getObjectLiteral() {    this.stuff = 'fruit';    return {      stuff: 'candy',      method: () =&gt; this.stuff,  // Returns 'fruit'    };  }}</code></pre>
      <h4 id="features-objects-shorthand-properties">
        5.3.6 Shorthand properties
      </h4>
      <p>На объектных литералах допустимы кратковременные свойства.</p>
      <p>Пример:</p>
      <pre><code class="language-js prettyprint">const foo = 1;const bar = 2;const obj = {  foo,  bar,  method() { return this.foo + this.bar; },};assertEquals(3, obj.method());</code></pre>
      <h4 id="features-objects-destructuring">5.3.7 Destructuring</h4>
      <p>
        Шаблоны деструкции объектов могут быть использованы слева от задания для
        выполнения деструкции и распаковки нескольких значений из одного
        объекта.
      </p>
      <p>
        Деструктурированные объекты могут также использоваться в качестве
        параметров функции, но их следует сохранять как можно проще: один
        уровень нецитируемых скорописных свойств. Более глубокие уровни
        вложенности и вычисленных свойств не могут использоваться при деструкции
        параметров. Укажите любые значения по умолчанию в левой части
        разрушаемого параметра (<code>{str = 'some default'} = {}</code>, а не
        <code class="badcode">{str} = {str: some default'}</code>), и если
        разрушенный объект сам по себе необязателен, то по умолчанию он должен
        иметь значение <code>{}</code>. JSDoc для разрушаемого параметра может
        быть присвоено любое имя (имя не используется, но требуется
        компилятору).
      </p>
      <p>Пример:</p>
      <pre><code class="language-js prettyprint">/** * @param {string} ordinary * @param {{num: (number|undefined), str: (string|undefined)}=} param1 *     num: The number of times to do something. *     str: A string to do stuff to. */function destructured(ordinary, {num, str = 'some default'} = {})</code></pre>
      <p>Запрещено:</p>
      <pre><code class="language-js prettyprint badcode">/** @param {{x: {num: (number|undefined), str: (string|undefined)}}} param1 */function nestedTooDeeply({x: {num, str}}) {};/** @param {{num: (number|undefined), str: (string|undefined)}=} param1 */function nonShorthandProperty({num: a, str: b} = {}) {};/** @param {{a: number, b: number}} param1 */function computedKey({a, b, [a + b]: c}) {};/** @param {{a: number, b: string}=} param1 */function nontrivialDefault({a, b} = {a: 2, b: 4}) {};</code></pre>
      <p>
        Деструктуризация также может быть использована для
        <code>goog.require</code> операторов, и в этом случае не должна быть
        обернута: весь оператор занимает одну строку, независимо от ее длины
        (см. <a href="#file-goog-require">?</a>).
      </p>
      <h4 id="features-objects-enums">5.3.8 Enums</h4>
      <p>
        Перечисления определяются добавлением аннотации <code>@enum</code> к
        буквальному объекту. Дополнительные свойства не могут быть добавлены в
        перечисление после его определения. Перечисления должны быть
        постоянными, и все значения перечислений должны быть глубоко
        неизменяемыми.
      </p>
      <pre><code class="language-js prettyprint">/** * Supported temperature scales. * @enum {string} */const TemperatureScale = {  CELSIUS: 'celsius',  FAHRENHEIT: 'fahrenheit',};/** * An enum with two options. * @enum {number} */const Option = {  /** The option used shall have been the first. */  FIRST_OPTION: 1,  /** The second among two options. */  SECOND_OPTION: 2,};</code></pre>
      <h3 id="features-classes">5.4 Classes</h3>
      <h4 id="features-classes-constructors">5.4.1 Constructors</h4>
      <p>
        Конструкторы являются необязательными. Конструкторы подклассов должны
        вызывать <code>super()</code> перед установкой любых полей или иным
        образом обращаться к <code>этому</code>. Интерфейсы должны объявлять
        неметодные свойства в конструкторе.
      </p>
      <h4 id="features-classes-fields">5.4.2 Fields</h4>
      <p>
        Установка всех конкретных объектов&#8217;s полей (т.е. всех свойств,
        кроме методов) в конструкторе. Аннотировать поля, которые никогда не
        переназначаются с помощью <code>@const</code> (они не должны быть
        глубоко неизменяемыми). Аннотируйте непубличные поля с правильной
        аннотацией видимости (<code>@private</code>,
        <code>@pro защищенные</code>, <code>@пакет</code>), и заканчивайте все
        <code>@private</code> имена полей подчеркиванием. Поля никогда не
        устанавливаются на конкретный класс' <code>прототип</code>.
      </p>
      <p>Пример:</p>
      <pre><code class="language-js prettyprint">class Foo {  constructor() {    /** @private @const {!Bar} */    this.bar_ = computeBar();    /** @protected @const {!Baz} */    this.baz = computeBaz();  }}</code></pre>
      <p>
        Подсказка: Свойства никогда не следует добавлять или удалять из
        экземпляра после завершения работы конструктора, так как это существенно
        затрудняет работу VMs&#8217; возможность оптимизации. При необходимости,
        поля, которые инициализируются позже, должны быть явно установлены в
        <code>undefined</code> в конструкторе для предотвращения последующих
        изменений формы. Добавление <code>@struct</code> в объект будет
        проверять, что необъявленные свойства не добавлены/недоступны. Классы
        добавляют это по умолчанию.
      </p>
      <h4 id="features-classes-computed-properties">
        5.4.3 Computed properties
      </h4>
      <p>
        Вычисленные свойства могут использоваться в классах только в том случае,
        если свойство является символом. Свойства в стиле пиктограммы (то есть,
        кавычки или вычисленные несимвольные ключи, как определено в
        <a href="#features-objects-mixing-клавиши">?</a>) не допускаются. Метод
        <code>[Symbol.iterator]</code> должен быть определен для любых классов,
        логически итерабельных. Кроме того, <code>Symbol</code> следует
        использовать экономно.
      </p>
      <p>
        Совет: будьте осторожны с использованием любых других встроенных
        символов (например, <code>Symbol.isConcatSpreadable</code>), так как они
        не заполняются компилятором и поэтому не будут работать в старых
        браузерах.
      </p>
      <h4 id="features-classes-static-methods">5.4.4 Static methods</h4>
      <p>
        Там, где это не мешает читабельности, предпочитают модульные локальные
        функции, а не приватные статические методы.
      </p>
      <p>
        Статические методы следует вызывать только в базовом классе. Статические
        методы не должны вызываться на переменные, содержащие динамический
        экземпляр, который может быть как конструктором, так и конструктором
        подкласса (и должен быть определен с помощью <code>@nocollapse</code>,
        если это сделано), и не должны вызываться непосредственно на подкласс,
        который не определяет сам метод.
      </p>
      <p>Запрещено:</p>
      <pre><code class="language-js prettyprint badcode">class Base { /** @nocollapse */ static foo() {} }class Sub extends Base {}function callFoo(cls) { cls.foo(); }  // discouraged: don't call static methods dynamicallySub.foo();  //  Запрещено: don't call static methods on subclasses that don't define it themselves</code></pre>
      <h4 id="features-classes-old-style">
        5.4.5 Old-style class declarations
      </h4>
      <p>
        Хотя классы ES6 являются предпочтительными, есть случаи, когда классы
        ES6 могут быть неосуществимы. Например:
      </p>
      <ol>
        <li>
          <p>
            Если существуют или будут существовать подклассы, включая структуры,
            которые создают подклассы, которые не могут быть немедленно изменены
            для использования синтаксиса классов ES6. Если бы такой класс
            использовал синтаксис ES6, то все последующие подклассы, не
            использующие синтаксис класса ES6, должны были бы быть изменены.
          </p>
        </li>
        <li>
          <p>
            Фреймворки, которые требуют известного значения
            <code>этого</code> перед вызовом конструктора суперкласса, поскольку
            конструкторы с ES6 суперклассами не имеют доступа к экземпляру
            <code>этому</code> значению до тех пор, пока не вернется вызов
            <code>super</code>.
          </p>
        </li>
      </ol>
      <p>
        Во всех других отношениях руководство по стилю все еще применяется к
        этому коду: <code>let</code>, <code>const</code>, при необходимости
        следует использовать параметры по умолчанию, функции rest и стрелки.
      </p>
      <p>
        <code>goog.defineClass</code> допускает классоподобное определение,
        аналогичное синтаксису класса ES6:
      </p>
      <pre><code class="language-javascript">let C = goog.defineClass(S, {  /**   * @param {string} value   */  constructor(value) {    S.call(this, 2);    /** @const */    this.prop = value;  },  /**   * @param {string} param   * @return {number}   */  method(param) {    return 0;  },});</code></pre>
      <p>
        Альтернативно, в то время как <code>goog.defineClass</code> должен быть
        предпочтительным для всего нового кода, более традиционный синтаксис
        также разрешен.
      </p>
      <pre><code class="language-javascript">/**  * @constructor @extends {S}  * @param {string} value  */function C(value) {  S.call(this, 2);  /** @const */  this.prop = value;}goog.inherits(C, S);/** * @param {string} param * @return {number} */C.prototype.method = function(param) {  return 0;};</code></pre>
      <p>
        Свойства экземпляра должны быть определены в конструкторе после вызова
        конструктора супер класса, если есть супер класс. Методы должны быть
        определены на прототипе конструктора.
      </p>
      <p>
        Правильно определить иерархии прототипов конструкторов сложнее, чем
        кажется на первый взгляд! По этой причине лучше всего использовать
        <code>goog.inherits</code> из
        <a href="http://code.google.com/closure/library/"
          >Библиотека "Closure" </a
        >.
      </p>
      <h4 id="features-classes-prototypes">
        5.4.6 Do not manipulate <code>prototype</code>s directly
      </h4>
      <p>
        Ключевое слово <code>класс</code> позволяет более четко и читаемо
        определить класс, чем определение свойств <code>прототипа</code>.
        Обычный код реализации не имеет никаких бизнес-манипуляций с этими
        объектами, хотя они все еще полезны для определения классов, как они
        определены в <a href="#features-классы-старый стиль">?</a>. Смешивать и
        модифицировать прототипы встроенных объектов явно запрещено.
      </p>
      <p>
        <strong>Exception</strong>: Код фреймворка (например, Polymer или
        Angular) может потребоваться использовать <code>прототип</code> и не
        должен прибегать к обходным путям, чтобы избежать этого.
      </p>
      <h4 id="features-classes-getters-and-setters">
        5.4.7 Getters and Setters
      </h4>
      <p>
        Не используйте
        <a
          href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get"
          >JavaScript getter и setter properties</a
        >. Они потенциально удивительны и трудны в рассуждениях, а также имеют
        ограниченную поддержку в компиляторе. Вместо этого предоставьте обычные
        методы.
      </p>
      <p>
        <strong>Exception</strong>: бывают ситуации, когда определение геттера
        или сеттера неизбежно (например, фреймворки привязки данных, такие как
        Angular и Polymer, или для совместимости с внешними API, которые
        невозможно настроить). Только в этих случаях можно использовать геттеры
        и сеттеры <em> с осторожностью</em> при условии, что они определены с
        помощью <code>get</code> и <code>set</code> коротких ключевых слов
        метода или <code>Object.defineProperties</code> (не
        <code>Object.defineProperty</code>, что мешает переименованию свойств).
        Геттеры <strong> не должны</strong> изменять наблюдаемое состояние.
      </p>
      <p>Запрещено:</p>
      <pre><code class="language-js prettyprint badcode">class Foo {  get next() { return this.nextId++; }}</code></pre>
      <h4 id="features-classes-overriding-tostring">
        5.4.8 Overriding toString
      </h4>
      <p>
        Метод <code>toString</code> может быть переопределен, но должен всегда
        иметь успех и никогда не иметь видимых побочных эффектов.
      </p>
      <p>
        Совет: Остерегайтесь, в частности, вызова других методов из ToString,
        так как исключительные условия могут привести к бесконечным циклам.
      </p>
      <h4 id="features-classes-interfaces">5.4.9 Interfaces</h4>
      <p>
        Интерфейсы могут быть объявлены с помощью <code>@интерфейса</code> или
        <code>@записи</code>. Интерфейсы, объявленные с помощью
        <code>@record</code> могут быть явно (т.е. через
        <code>@implements</code>) или неявно реализованы классом или литералом
        объекта.
      </p>
      <p>
        Все нестатические тела методов на интерфейсе должны быть пустыми
        блоками. Поля должны быть объявлены как неинициализированные члены в
        конструкторе класса.
      </p>
      <p>Пример:</p>
      <pre><code class="language-js prettyprint">/** * Something that can frobnicate. * @record */class Frobnicator {  constructor() {    /** @type {number} The number of attempts before giving up. */    this.attempts;  }  /**   * Performs the frobnication according to the given strategy.   * @param {!FrobnicationStrategy} strategy   */  frobnicate(strategy) {}}</code></pre>
      <h4 id="features-classes-abstract-classes">5.4.10 Abstract Classes</h4>
      <p>
        При необходимости используйте абстрактные классы. Абстрактные классы и
        методы должны быть аннотированы с помощью <code>@абстрактный</code>. Не
        используйте <code>goog.abstractMethod</code>. Смотрите
        <a
          href="https://github.com/google/closure-compiler/wiki/@abstract classes-and-methods"
          >abstract classes and methods</a
        >.
      </p>
      <h3 id="features-functions">5.5 Functions</h3>
      <h4 id="features-functions-top-level-functions">
        5.5.1 Top-level functions
      </h4>
      <p>
        Функции верхнего уровня могут быть определены непосредственно в объекте
        <code>exports</code>, или же объявлены локально и опционально
        экспортированы. Дополнительную информацию об экспорте см. в разделе
        <a href="#file-goog-module-exports">?</a>.
      </p>
      <p>Примеры:</p>
      <pre><code class="language-js prettyprint">/** @param {string} str */exports.processString = (str) =&gt; {  // Process the string.};</code></pre>
      <pre><code class="language-js prettyprint">/** @param {string} str */const processString = (str) =&gt; {  // Process the string.};exports = {processString};</code></pre>
      <h4 id="features-functions-nested-functions">
        5.5.2 Nested functions and closures
      </h4>
      <p>
        Функции могут содержать вложенные определения функций. Если полезно дать
        функции имя, она должна быть присвоена локальному <code>const</code>.
      </p>
      <h4 id="features-functions-arrow-functions">5.5.3 Arrow functions</h4>
      <p>
        Функции со стрелками обеспечивают лаконичный синтаксис функций и
        упрощают поиск <code>этот</code> для вложенных функций. Функции стрелок
        предпочитают ключевое слово <code>function</code>, особенно для
        вложенных функций (но смотрите
        <a href="#features-objects-method-shorthand">?</a>).
      </p>
      <p>
        Предпочтителен функции стрелок над другими <code>это</code> подходами к
        определению масштаба, такими как <code>f.bind(this)</code>,
        <code>goog.bind(f, this)</code>, и <code>const self = this</code>.
        Функции стрелок особенно полезны для вызова обратных вызовов, так как
        они позволяют явно указывать, какие параметры должны передаваться
        обратному вызову, в то время как привязка будет слепо передавать все
        параметры.
      </p>
      <p>
        Левая часть стрелки содержит ноль или более параметров. Круглые скобки
        вокруг параметров являются необязательными, если есть только один
        неразрушенный параметр. При использовании круглых скобок можно указывать
        типы параметров в строке (см.
        <a href="#jsdoc-метод и функции-комментарии">?</a>).
      </p>
      <p>
        Подсказка: Всегда использование круглых скобок даже для
        однопараметрических функций со стрелками позволяет избежать ситуаций,
        когда добавление параметров, но забыв добавить круглые скобки, может
        привести к появлению разобранного кода, который больше не работает так,
        как задумывалось.
      </p>
      <p>
        В правой части стрелки находится тело функции. По умолчанию тело - это
        блочный оператор (нулевой или более операторов, окруженный фигурными
        скобками). Тело также может быть неявно возвращенным единичным
        выражением, если либо: логика программы требует возврата значения, либо
        оператор <code>void</code> предшествует вызову одной функции или метода
        (использование <code>void</code> обеспечивает возврат
        <code>неопределенного</code>, предотвращает утечку значений и сообщает о
        намерении). Форма единственного выражения предпочтительнее, если она
        улучшает читабельность (например, для коротких или простых выражений).
      </p>
      <p>Примеры:</p>
      <pre><code class="language-js prettyprint">/** * Arrow functions can be documented just like normal functions. * @param {number} numParam A number to add. * @param {string} strParam Another number to add that happens to be a string. * @return {number} The sum of the two parameters. */const moduleLocalFunc = (numParam, strParam) =&gt; numParam + Number(strParam);// Uses the single expression syntax with `void` because the program logic does// not require returning a value.getValue((result) =&gt; void alert(`Got ${result}`));class Callback Пример {  constructor() {    /** @private {number} */    this.cachedValue_ = 0;    // For inline callbacks, you can use inline typing for parameters.    // Uses a block statement because the value of the single expression should    // not be returned and the expression is not a single function call.    getNullableValue((/** ?number */ result) =&gt; {      this.cachedValue_ = result == null ? 0 : result;    });  }}</code></pre>
      <p>Запрещено:</p>
      <pre><code class="language-js prettyprint badcode">/** * A function with no params and no returned value. * This single expression body usage is illegal because the program logic does * not require returning a value and we're missing the `void` operator. */const moduleLocalFunc = () =&gt; anotherFunction();</code></pre>
      <h4 id="features-functions-generators">5.5.4 Generators</h4>
      <p>
        Генераторы позволяют использовать ряд полезных абстракций и могут быть
        использованы по мере необходимости.
      </p>
      <p>
        При определении функций генератора, прикрепите <code>*</code> к
        ключевому слову <code>функции</code>, когда оно присутствует, и отделите
        его пробелом от имени функции. При использовании делегирования полей
        приложите <code>*</code> к ключевому слову <code>поле</code>.
      </p>
      <p>Пример:</p>
      <pre><code class="language-js prettyprint">/** @return {!Iterator&lt;number&gt;} */function* gen1() {  yield 42;}/** @return {!Iterator&lt;number&gt;} */const gen2 = function*() {  yield* gen1();}class SomeClass {  /** @return {!Iterator&lt;number&gt;} */  * gen() {    yield 42;  }}</code></pre>
      <h4 id="features-functions-parameter-return-types">
        5.5.5 Parameter and return types
      </h4>
      <p>
        Параметры функции и возвращаемые типы обычно должны быть
        задокументированы с помощью JSDoc аннотаций. Смотрите
        <a href="#jsdoc-метод и функция-комментарии">?</a> для получения
        дополнительной информации.
      </p>
      <h5 id="features-functions-default-parameters">
        5.5.5.1 Default parameters
      </h5>
      <p>
        Допускается использование опциональных параметров с помощью оператора
        equals в списке параметров. Опциональные параметры должны включать
        пробелы с обеих сторон оператора equals, именоваться точно так же, как и
        требуемые параметры (т.е. не префиксоваться с помощью
        <code>opt_</code>), использовать суффикс <code>=</code> в их JSDoc-типе,
        приходить после требуемых параметров и не использовать инициализаторы,
        которые создают наблюдаемые побочные эффекты. Все опциональные параметры
        для конкретных функций должны иметь значения по умолчанию, даже если это
        значение <code>undefined</code>. В отличие от конкретных функций,
        абстрактный и интерфейсный методы должны опускать значения параметров по
        умолчанию.
      </p>
      <p>Пример:</p>
      <pre><code class="language-js prettyprint">/** * @param {string} required This parameter is always needed. * @param {string=} optional This parameter can be omitted. * @param {!Node=} node Another optional parameter. */function maybeDoSomething(required, optional = '', node = undefined) {}/** @interface */class MyInterface {  /**   * Interface and abstract methods must omit default parameter values.   * @param {string=} optional   */  someMethod(optional) {}}</code></pre>
      <p>
        Используйте параметры по умолчанию экономно. Предпочтителено
        деструктирование (как в <a href="#features-objects-destructuring">?</a>)
        для создания читаемых API, когда есть более чем небольшое количество
        опциональных параметров, которые не имеют естественного порядка.
      </p>
      <p>
        Примечание: В отличие от параметров Python по умолчанию, можно
        использовать инициализаторы, которые возвращают новые мутируемые объекты
        (такие как <code>{}</code> или <code>[]</code>), потому что
        инициализатор оценивается каждый раз при использовании значения по
        умолчанию, поэтому один объект не будет совместно использоваться между
        вызовами.
      </p>
      <p>
        Подсказка: Хотя в качестве инициализаторов могут использоваться
        произвольные выражения, включая вызовы функций, их следует сохранять как
        можно более простыми. Избегайте инициализаторов, показывающих общее
        мутируемое состояние, так как это может легко привести к
        непреднамеренной связи между вызовами функций.
      </p>
      <h5 id="features-functions-rest-parameters">5.5.5.2 Rest parameters</h5>
      <p>
        Используйте параметр <em>rest</em> вместо доступа к
        <code>аргументам</code>. Параметры отдыха набираются с префиксом
        <code>...</code> в JSDoc. Остальной параметр должен быть последним в
        списке. Между <code>...</code> и именем параметра нет пробела. Не
        называйте параметр rest <code>var_args</code>. Никогда не называйте
        локальную переменную или параметр <code>arguments</code>, который путано
        отбрасывает тень на встроенное имя.
      </p>
      <p>Пример:</p>
      <pre><code class="language-js prettyprint">/** * @param {!Array&lt;string&gt;} array This is an ordinary parameter. * @param {...number} numbers The remainder of arguments are all numbers. */function variadic(array, ...numbers) {}</code></pre>
      <h4 id="features-functions-generics">5.5.6 Generics</h4>
      <p>
        Объявите общие функции и методы, когда это необходимо, с помощью
        <code>@типа шаблона TYPE</code> в JSDoc над определением функции или
        метода.
      </p>
      <h4 id="features-functions-spread-operator">5.5.7 Spread operator</h4>
      <p>
        Вызовы функций могут использовать оператор спреда (<code>...</code>).
        Предпочтителен оператор spread перед
        <code>Function.prototype.apply</code> при распаковке массива или
        итерабельного метода в несколько параметров вариадической функции.
        Пробел после <code>...</code> отсутствует.
      </p>
      <p>Пример:</p>
      <pre><code class="language-js prettyprint">function myFunction(...elements) {}myFunction(...array, ...iterable, ...generator());</code></pre>
      <h3 id="features-string-literals">5.6 String literals</h3>
      <h4 id="features-strings-use-single-quotes">5.6.1 Use single quotes</h4>
      <p>
        Обычные строковые литералы разделяются одиночными кавычками
        (<code>'</code>), а не двойными кавычками (<code>"</code>).
      </p>
      <p>
        Подсказка: если строка содержит символ одиночной кавычки, рассмотрите
        возможность использования строки-шаблона, чтобы избежать необходимости
        экранирования кавычек.
      </p>
      <p>Обычные строковые литералы не могут охватывать несколько строк.</p>
      <h4 id="features-strings-template-strings">5.6.2 Template literals</h4>
      <p>
        Используйте шаблонные литералы (разделенные <code>`</code>) над сложной
        конкатеннацией строк, особенно если речь идет о многострочных литералах.
        Шаблонные литералы могут занимать несколько строк.
      </p>
      <p>
        Если шаблонный литерал охватывает несколько строк, ему не нужно
        следовать за отступом ограждающего блока, хотя это может произойти, если
        добавленные пробельные символы не имеют значения.
      </p>
      <p>Пример:</p>
      <pre><code class="language-js prettyprint">function arithmetic(a, b) {  return `Here is a table of arithmetic operations:${a} + ${b} = ${a + b}${a} - ${b} = ${a - b}${a} * ${b} = ${a * b}${a} / ${b} = ${a / b}`;}</code></pre>
      <h4 id="features-strings-no-line-continuations">
        5.6.3 No line continuations
      </h4>
      <p>
        Не используйте <em>продолжения строк</em> (то есть завершение строки
        внутри строкового литерала обратным слешем) ни в обычных, ни в шаблонных
        строковых литералах. Хотя ES5 позволяет это, это может привести к хитрым
        ошибкам, если любой трейлинговый пробельный символ приходит после косой
        черты, и менее очевиден для читателей.
      </p>
      <p>Запрещено:</p>
      <pre><code class="language-js prettyprint badcode">const longString = 'This is a very long string that far exceeds the 80 \    column limit. It unfortunately contains long stretches of spaces due \    to how the continued lines are indented.';</code></pre>
      <p>Вместо этого напишите</p>
      <pre><code class="language-js prettyprint">const longString = 'This is a very long string that far exceeds the 80 ' +    'column limit. It does not contain long stretches of spaces since ' +    'the concatenated strings are cleaner.';</code></pre>
      <h3 id="features-number-literals">5.7 Number literals</h3>
      <p>
        Числа могут быть указаны в десятичной, шестнадцатеричной, восьмеричной
        или двоичной форме. Используйте точные префиксы <code>0x</code>,
        <code>0o</code> и <code>0b</code>, с строчными буквами, для
        шестнадцатеричных, восьмеричных и двоичных, соответственно. Никогда не
        включайте ведущий ноль, если за ним не следуют <code>x</code>,
        <code>o</code> или <code>b</code>.
      </p>
      <h3 id="features-control-structures">5.8 Control structures</h3>
      <h4 id="features-for-loops">5.8.1 For loops</h4>
      <p>
        В ES6 язык теперь имеет три различных типа циклов <code> для</code>. Все
        они могут использоваться, хотя <code> для</code>-<code>of</code> циклов
        должны быть предпочтительны, когда это возможно.
      </p>
      <p>
        <code> для</code>-<code>в</code> циклах можно использовать только для
        объектов в стиле диктата (см.
        <a href="#features-objects-mixing-клавиши">?</a>), и их не следует
        использовать для итераций по массиву.
        <code>Object.prototype.hasOwnProperty</code> следует использовать в
        <code> для</code>-<code>в</code>циклах для исключения нежелательных
        свойств прототипа. Предпочтите <code> для</code>-<code>of</code> и
        <code>Object.keys</code> над <code> для</code>-<code>в</code> когда это
        возможно.
      </p>
      <h4 id="features-exceptions">5.8.2 Exceptions</h4>
      <p>
        Исключения являются важной частью языка и должны использоваться всякий
        раз, когда возникают исключительные случаи. Всегда бросайте
        <code>Error</code>s или подклассы <code>Error</code>: никогда не
        бросайте строковые литералы или другие объекты. Всегда используйте
        <code>new</code> при построении <code>Error</code>.
      </p>
      <p>
        Эта обработка распространяется на <code>Promise</code> значения
        отклонения, поскольку <code>Promise.rejection(obj)</code> эквивалентно
        <code>throw obj;</code> в асинхронных функциях.
      </p>
      <p>
        Пользовательские исключения обеспечивают отличный способ передачи
        дополнительной информации об ошибках от функций. Они должны быть
        определены и использованы везде, где родной тип
        <code>Error</code> недостаточен.
      </p>
      <p>
        Предпочтение отдается бросанию исключений, а не специальным подходам к
        обработке ошибок (таким как передача типа ссылки на контейнер ошибок или
        возврат объекта со свойством ошибки).
      </p>
      <h5 id="features-empty-catch-blocks">5.8.2.1 Empty catch blocks</h5>
      <p>
        Очень редко корректно ничего не делать в ответ на пойманное исключение.
        Когда действительно уместно не предпринимать никаких действий в блоке
        catch, причина, по которой это оправдано, объясняется в комментарии.
      </p>
      <pre><code class="language-js prettyprint">try {  return handleNumericResponse(response);} catch (ok) {  // it's not numeric; that's fine, just continue}return handleTextResponse(response);</code></pre>
      <p>Запрещено:</p>
      <pre><code class="language-js prettyprint badcode">  try {    shouldFail();    fail('expected an error');  } catch (expected) {  }</code></pre>
      <p>
        Совет: В отличие от некоторых других языков, шаблоны, подобные
        вышеприведенным, просто don&#8217;t работают, так как они будут ловить
        ошибку, брошенную <code>fail</code>. Вместо этого используйте
        <code>assertThrows()</code>.
      </p>
      <h4 id="features-switch-statements">5.8.3 Switch statements</h4>
      <p>
        Замечание по терминологии: Внутри фигурных скобок блока переключателей
        находятся одна или несколько групп операторов. Каждая группа операторов
        состоит из одной или нескольких меток переключателя (либо
        <code>case FOO:</code> или <code>default:</code>), за которыми следует
        один или несколько операторов.
      </p>
      <h5 id="features-switch-fall-through">5.8.3.1 Fall-through: commented</h5>
      <p>
        Внутри блока переключателей каждая группа операторов либо прерывается
        внезапно (с помощью <code>броса</code>, <code>возврата</code> или
        <code>бросает</code>n исключение), либо помечается комментарием,
        указывающим на то, что выполнение будет или может быть продолжено в
        следующей группе операторов. Достаточно любого комментария, который
        передает идею падения (обычно <code>// попадает в</code>). Этот
        специальный комментарий не требуется в последней группе операторов в
        блоке переключателей.
      </p>
      <p>Пример:</p>
      <pre><code class="language-js prettyprint">switch (input) {  case 1:  case 2:    prepareOneOrTwo();  // fall through  case 3:    handleOneTwoOrThree();    break;  default:    handleLargeNumber(input);}</code></pre>
      <h5 id="features-switch-default-case">
        5.8.3.2 The <code>default</code> case is present
      </h5>
      <p>
        Каждый оператор-переключатель включает группу операторов
        <code>default</code>, даже если он не содержит кода. Группа операторов
        <code>default</code> должна быть последней.
      </p>
      <h3 id="features-this">5.9 this</h3>
      <p>
        Используйте только <code>этот</code> в конструкторах и методах класса, в
        функциях со стрелками, определенных внутри конструкторов и методов
        класса, или в функциях, которые имеют явный <code>@это</code>,
        объявленный в JSDoc в функции немедленного закрытия&#8217;s.
      </p>
      <p>
        Никогда не используйте <code>это</code> для обращения к глобальному
        объекту, контексту <code>eval</code>, цели события, или неоправданно
        <code></code><code>call()</code>ed или <code>apply()</code>ed функций.
      </p>
      <h3 id="features-equality-checks">5.10 Equality Checks</h3>
      <p>
        Используйте операторы идентификации (<code>===</code>/<code>!==</code>),
        за исключением случаев, описанных ниже.
      </p>
      <h4 id="features-equality-checks-exceptions">
        5.10.1 Exceptions Where Coercion is Desirable
      </h4>
      <p>Поймать оба значения <code>null</code> и <code>undefined</code>:</p>
      <pre><code class="language-js prettyprint">if (someObjectOrPrimitive == null) {  // Checking for null catches both null and undefined for objects and  // primitives, but does not catch other falsy values like 0 or the empty  // string.}</code></pre>
      <h3 id="disallowed-features">5.11 Disallowed features</h3>
      <h4 id="disallowed-features-with">5.11.1 with</h4>
      <p>
        Не используйте <code> с ключевым словом</code>. Это делает ваш код более
        трудным для понимания и был запрещен в строгом режиме со времен ES5.
      </p>
      <h4 id="disallowed-features-dynamic-code-evaluation">
        5.11.2 Dynamic code evaluation
      </h4>
      <p>
        Не используйте <code>eval</code> или конструктор
        <code>Function(...string)</code> (за исключением загрузчиков кода). Эти
        возможности потенциально опасны и просто не работают в среде CSP.
      </p>
      <h4 id="disallowed-features-automatic-semicolon-insertion">
        5.11.3 Automatic semicolon insertion
      </h4>
      <p>
        Всегда завершайте выражения точкой с запятой (за исключением объявлений
        функций и классов, как было отмечено выше).
      </p>
      <h4 id="disallowed-features-non-standard-features">
        5.11.4 Non-standard features
      </h4>
      <p>
        Не используйте нестандартные функции. Сюда относятся старые функции,
        которые были удалены (например, <code>WeakMap.clear</code>), новые
        функции, которые еще не стандартизированы (например, текущий рабочий
        проект TC39, предложения на любом этапе, или предлагаемые, но не
        исчерпывающие веб-стандарты), или проприетарные функции, которые
        реализованы только в некоторых браузерах. Используйте только те функции,
        которые определены в текущих стандартах ECMA-262 или WHATWG. (Обратите
        внимание, что проекты, пишущие против определенных API, таких как
        расширения Chrome или Node.js, очевидно, могут использовать эти API).
        Нестандартный язык &#8220; расширения &#8221; (например, предоставляемые
        некоторыми внешними транспайлерами) запрещены.
      </p>
      <h4 id="disallowed-features-wrapper-objects">
        5.11.5 Wrapper objects for primitive types
      </h4>
      <p>
        Никогда не используйте <code>new</code> на обертках примитивных объектов
        (<code>Boolean</code>, <code>Number</code>, <code>String</code>,
        <code>Symbol</code>), а также не включайте их в аннотации к типам.
      </p>
      <p>Запрещено:</p>
      <pre><code class="language-js prettyprint badcode">const /** Boolean */ x = new Boolean(false);if (x) alert(typeof x);  // alerts 'object' - WAT?</code></pre>
      <p>
        Обертки могут вызываться как функции для принуждения (что
        предпочтительнее, чем использование <code>+</code> или конкатенация
        пустой строки) или создания символов.
      </p>
      <p>Пример:</p>
      <pre><code class="language-js prettyprint">const /** boolean */ x = Boolean(0);if (!x) alert(typeof x);  // alerts 'boolean', as expected</code></pre>
      <h4 id="disallowed-features-modifying-builtin-objects">
        5.11.6 Modifying builtin objects
      </h4>
      <p>
        Никогда не модифицируйте типы builtin, добавляя методы в свои
        конструкторы или прототипы. Избегайте зависимости от библиотек, которые
        это делают. Обратите внимание, что библиотека исполнения
        JSCompiler&#8217;s по возможности предоставляет полифайлы,
        соответствующие стандартам; больше ничто не может модифицировать
        встроенные объекты.
      </p>
      <p>
        Не добавляйте символы в глобальный объект, если только это не является
        абсолютно необходимым (например, требуется сторонним API).
      </p>
      <h4 id="disallowed-features-omitting-parents-with-new">
        5.11.7 Omitting <code>()</code> when invoking a constructor
      </h4>
      <p>
        Никогда не вызывайте конструктор в операторе <code>new</code> без
        использования скобок <code>()</code>.
      </p>
      <p>Запрещено:</p>
      <pre><code class="language-js prettyprint badcode">new Foo;</code></pre>
      <p>Использовать вместо этого:</p>
      <pre><code class="language-js prettyprint">new Foo();</code></pre>
      <p>
        Упущение скобок может привести к едва уловимым ошибкам. Эти две строки
        не эквивалентны:
      </p>
      <pre><code class="language-js prettyprint">new Foo().Bar();new Foo.Bar();</code></pre>
      <h2 id="naming">6 Naming</h2>
      <h3 id="naming-rules-common-to-all-identifiers">
        6.1 Rules common to all identifiers
      </h3>
      <p>
        Идентификаторы используют только ASCII-буквы и цифры, и в небольшом
        количестве случаев, отмеченных ниже, подчеркивают и очень редко (когда
        этого требуют такие фреймворки, как Угловые) знаки доллара.
      </p>
      <p>
        Дайте как можно более описательное название в пределах разумного. Не
        беспокойтесь об экономии горизонтального пространства, т.к. гораздо
        важнее сделать свой код сразу же понятным для нового читателя. Не
        используйте аббревиатуры, которые являются двусмысленными или
        незнакомыми для читателей вне Вашего проекта, и не сокращайте, удаляя
        буквы внутри слова.
      </p>
      <pre><code class="language-js prettyprint">errorCount          // No abbreviation.dnsConnectionIndex  // Most people know what "DNS" stands for.referrerUrl         // Ditto for "URL".customerId          // "Id" is both ubiquitous and unlikely to be misunderstood.</code></pre>
      <p>Запрещено:</p>
      <pre><code class="language-js prettyprint badcode">n                   // Meaningless.nErr                // Ambiguous abbreviation.nCompConns          // Ambiguous abbreviation.wgcConnections      // Only your group knows what this stands for.pcReader            // Lots of things can be abbreviated "pc".cstmrId             // Deletes internal letters.kSecondsPerDay      // Do not use Hungarian notation.</code></pre>
      <h3 id="naming-rules-by-identifier-type">6.2 Rules by identifier type</h3>
      <h4 id="naming-package-names">6.2.1 Package names</h4>
      <p>
        Имена всех пакетов <code>lowerCamelCase</code>. Например,
        <code>my.exampleCode.deepSpace</code>, но не
        <code class="badcode">my.examplecode.deepspace</code> или
        <code class="badcode">my.example_code.deep_space</code>.
      </p>
      <h4 id="naming-class-names">6.2.2 Class names</h4>
      <p>
        Имена классов, интерфейса, записи и typedef записываются в
        <code>UpperCamelCase</code>. Неэкспортируемые классы являются просто
        локальными: они не помечены <code>@private</code> и поэтому не именуются
        с трейлинговым подчеркиванием.
      </p>
      <p>
        Имена типов обычно представляют собой существительные или фразы
        существительных. Например, <code>Request</code>,
        <code>ImmutableList</code> или <code>VisibilityMode</code>. Кроме того,
        имена интерфейсов иногда могут быть прилагательными или прилагательными
        фразами (например, <code>Readable</code>).
      </p>
      <h4 id="naming-method-names">6.2.3 Method names</h4>
      <p>
        Имена методов записываются в <code>lowerCamelCase</code>. Имена методов
        <code>@private</code> должны заканчиваться трейлинговым подчеркиванием.
      </p>
      <p>
        Имена методов обычно представляют собой глаголы или глагольные фразы.
        Например, <code>sendMessage</code> или <code>stop_</code>. Методы getter
        и setter для свойств никогда не требуются, но если они используются, то
        они должны быть названы <code>getFoo</code> (или опционально
        <code>isFoo</code> или <code>hasFoo</code> для booleans), или
        <code>setFoo(value)</code> для setters.
      </p>
      <p>
        Подчёркивания могут также появляться в именах методов тестирования
        JsUnit для разделения логических компонентов имени. Одним из типичных
        паттернов является
        <code
          >test&lt;MethodUnderTest&gt;_&lt;state&gt;_&lt;expectedOutcome&gt;</code
        >, например <code>testPop_emptyStack_throws</code>. Нет единого
        правильного способа назвать методы тестирования.
      </p>
      <h4 id="naming-enum-names">6.2.4 Enum names</h4>
      <p>
        Имена перечислений записываются в <code>UpperCamelCase</code>,
        аналогично классам, и обычно должны быть единичными существительными.
        Отдельные элементы внутри перечисления именуются в
        <code>CONSTANT_CASE</code>.
      </p>
      <h4 id="naming-constant-names">6.2.5 Constant names</h4>
      <p>
        Постоянные имена используют <code>CONSTANT_CASE</code>: все заглавные
        буквы, слова разделены подчеркиванием. Нет причин для именования
        константы с трейлинговым подчеркиванием, так как приватные статические
        свойства могут быть заменены (неявно приватными) локальными модулями.
      </p>
      <h5 id="naming-definition-of-constant">
        6.2.5.1 Definition of &#8220;constant&#8221;
      </h5>
      <p>
        Каждая константа представляет собой <code>@const</code> статическое
        свойство или модуль-локальное <code>const</code> объявление, но не все
        <code>@const</code> статические свойства, а модуль-локальные
        <code>const</code>s являются константами. Перед тем, как выбрать
        константный регистр, подумайте, действительно ли поле похоже на
        <em>глубоко неизменяемую </em> константу. Например, если какое-либо из
        наблюдаемых состояний этого экземпляра может измениться, то это почти
        наверняка не константа. Простого намерения никогда не мутировать объект,
        как правило, недостаточно.
      </p>
      <p>Примеры:</p>
      <pre><code class="language-js prettyprint">// Constantsconst NUMBER = 5;/** @const */ exports.NAMES = ImmutableList.of('Ed', 'Ann');/** @enum */ exports.SomeEnum = { ENUM_CONSTANT: 'value' };// Not constantslet letVariable = 'non-const';class MyClass { constructor() { /** @const {string} */ this.nonStatic = 'non-static'; } };/** @type {string} */ MyClass.staticButMutable = 'not @const, can be reassigned';const /** Set&lt;string&gt; */ mutableCollection = new Set();const /** ImmutableSet&lt;SomeMutableType&gt; */ mutableElements = ImmutableSet.of(mutable);const Foo = goog.require('my.Foo');  // mirrors imported nameconst logger = log.getLogger('loggers.are.not.immutable');</code></pre>
      <p>
        Constants&#8217; имена обычно представляют собой существительные или
        существительные фразы.
      </p>
      <h5 id="naming-local-aliases">6.2.5.2 Local aliases</h5>
      <p>
        Локальные псевдонимы следует использовать всякий раз, когда они улучшают
        читабельность по сравнению с полностью квалифицированными именами.
        Следуйте тем же правилам, что и <code>goog.require</code>s (<a
          href="#file-goog-require"
          >?</a
        >), сохраняя последнюю часть псевдонима. Псевдонимы также могут
        использоваться внутри функций. Псевдонимы должны быть
        <code>const</code>.
      </p>
      <p>Примеры:</p>
      <pre><code class="language-js prettyprint">const staticHelper = importedNamespace.staticHelper;const CONSTANT_NAME = ImportedClass.CONSTANT_NAME;const {assert, assertInstanceof} = asserts;</code></pre>
      <h4 id="naming-non-constant-field-names">
        6.2.6 Non-constant field names
      </h4>
      <p>
        Неконстантные имена полей (статические или иные) записываются в
        <code>lowerCamelCase</code>, с трейлинговым подчеркиванием для приватных
        полей.
      </p>
      <p>
        Эти имена обычно являются существительными или фразами существительных.
        Например, <code>computedValues</code> или <code>index_</code>.
      </p>
      <h4 id="naming-parameter-names">6.2.7 Parameter names</h4>
      <p>
        Имена параметров записываются в <code>lowerCamelCase</code>. Обратите
        внимание, что это применимо, даже если параметр ожидает конструктор.
      </p>
      <p>
        Односимвольные имена параметров не должны использоваться в публичных
        методах.
      </p>
      <p>
        <strong>Exception</strong>: По требованию стороннего фреймворка имена
        параметров могут начинаться с <code>$</code>. Это исключение не
        распространяется на любые другие идентификаторы (например, локальные
        переменные или свойства).
      </p>
      <h4 id="naming-local-variable-names">6.2.8 Local variable names</h4>
      <p>
        Имена локальных переменных записываются в <code>lowerCamelCase</code>,
        за исключением модульно-локальных (верхнего уровня) констант, как
        описано выше. Имена констант в функциональных областях по-прежнему
        написаны в <code>lowerCamelCase</code>. Обратите внимание, что
        <code>lowerCamelCase</code> используется, даже если переменная содержит
        конструктор.
      </p>
      <h4 id="naming-template-parameter-names">
        6.2.9 Template parameter names
      </h4>
      <p>
        Имена параметров шаблона должны быть краткими, однозначными или
        однобуквенными идентификаторами, и должны быть all-caps, например
        <code>TYPE</code> или <code>THIS</code>.
      </p>
      <h4 id="naming-module-local-names">6.2.10 Module-local names</h4>
      <p>
        Имена модулей, которые не экспортируются, являются неявно закрытыми. Они
        не помечены <code>@приватный</code> и не заканчиваются подчеркиванием.
        Это относится к классам, функциям, переменным, константам, перечислениям
        и другим модульно-локальным идентификаторам.
      </p>
      <h3 id="naming-camel-case-defined">6.3 Camel case: defined</h3>
      <p>
        Иногда существует более одного разумного способа преобразования
        английской фразы в верблюжью пазуху, например, когда присутствуют
        аббревиатуры или необычные конструкции вроде <q>IPv6</q> или <q>iOS</q>.
        Для повышения предсказуемости Google Style задает следующую (почти)
        детерминистическую схему.
      </p>
      <p>Начиная с прозаической формы имени:</p>
      <ol>
        <li>
          Convert the phrase to plain ASCII and remove any apostrophes. For
          example, <q>M&#252;ller's algorithm</q> might become
          <q>Muellers algorithm</q>.
        </li>
        <li>
          Divide this result into words, splitting on spaces and any remaining
          punctuation (typically hyphens).
          <ol>
            <li>
              Recommended: if any word already has a conventional camel case
              appearance in common usage, split this into its constituent parts
              (e.g., <q>AdWords</q> becomes <q>ad words</q>). Note that a word
              such as <q>iOS</q> is not really in camel case per se; it defies
              any convention, so this recommendation does not apply.
            </li>
          </ol>
        </li>
        <li>
          Now lowercase everything (including acronyms), then uppercase only the
          first character of:
          <ol>
            <li>&#8230; each word, to yield upper camel case, or</li>
            <li>
              &#8230; each word except the first, to yield lower camel case
            </li>
          </ol>
        </li>
        <li>Finally, join all the words into a single identifier.</li>
      </ol>
      <p>
        Обратите внимание, что оболочка исходных слов почти полностью
        игнорируется.
      </p>
      <p>Примеры:</p>
      <table>
        <thead>
          <tr>
            <th style="text-align: center">Prose form</th>
            <th style="text-align: center">Correct</th>
            <th style="text-align: center">Incorrect</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td style="text-align: center"><q>XML HTTP request</q></td>
            <td style="text-align: center">XmlHttpRequest</td>
            <td style="text-align: center">XMLHTTPRequest</td>
          </tr>
          <tr>
            <td style="text-align: center"><q>new customer ID</q></td>
            <td style="text-align: center">newCustomerId</td>
            <td style="text-align: center">newCustomerID</td>
          </tr>
          <tr>
            <td style="text-align: center"><q>inner stopwatch</q></td>
            <td style="text-align: center">innerStopwatch</td>
            <td style="text-align: center">innerStopWatch</td>
          </tr>
          <tr>
            <td style="text-align: center"><q>supports IPv6 on iOS?</q></td>
            <td style="text-align: center">supportsIpv6OnIos</td>
            <td style="text-align: center">supportsIPv6OnIOS</td>
          </tr>
          <tr>
            <td style="text-align: center"><q>YouTube importer</q></td>
            <td style="text-align: center">YouTubeImporter</td>
            <td style="text-align: center">YoutubeImporter*</td>
          </tr>
        </tbody>
      </table>
      <p>*Приемлемо, но не рекомендуется.</p>
      <p>
        Примечание: некоторые слова в английском языке неоднозначно
        дефинированы: например, <q>nonempty</q> и <q>non-empty</q> оба
        правильны, поэтому имена методов checkNonempty и checkNonEmpty также
        правильны.
      </p>
      <h2 id="jsdoc">7 JSDoc</h2>
      <p>
        <a
          href="https://developers.google.com/closure/compiler/docs/js-for-compiler"
          >JSDoc</a
        >
        используется для всех классов, полей и методов.
      </p>
      <h3 id="jsdoc-general-form">7.1 General form</h3>
      <p>Основное форматирование блоков JSDoc, как показано в этом примере:</p>
      <pre><code class="language-js prettyprint">/** * Multiple lines of JSDoc text are written here, * wrapped normally. * @param {number} arg A number to do something to. */function doSomething(arg) { &#8230; }</code></pre>
      <p>или в этом однострочном примере:</p>
      <pre><code class="language-js prettyprint">/** @const @private {!Foo} A short bit of JSDoc. */this.foo_ = foo;</code></pre>
      <p>
        Если однострочный комментарий переполняется на несколько строк, он
        должен использовать многострочный стиль с <code>/**</code> и
        <code>*/</code> на своих строках.
      </p>
      <p>
        Многие инструменты извлекают метаданные из комментариев JSDoc для
        выполнения валидации и оптимизации кода. Поэтому эти комментарии
        <strong>должны</strong> быть хорошо сформированы.
      </p>
      <h3 id="jsdoc-markdown">7.2 Markdown</h3>
      <p>
        JSDoc написан на языке Markdown, хотя при необходимости может включать
        HTML.
      </p>
      <p>
        Обратите внимание, что инструменты, которые автоматически извлекают
        JSDoc (например,
        <a href="https://github.com/jleyba/js-dossier">JsDossier</a>) часто
        игнорируют форматирование обычного текста, так что если вы это сделаете:
      </p>
      <pre><code class="language-js prettyprint badcode">/** * Computes weight based on three factors: *   items sent *   items received *   last timestamp */</code></pre>
      <p>это получится вот так:</p>
      <pre><code>Computes weight based on three factors: items sent items received last timestamp</code></pre>
      <p>Вместо этого напишите список Markdown:</p>
      <pre><code class="language-js prettyprint">/** * Computes weight based on three factors: * *  - items sent *  - items received *  - last timestamp */</code></pre>
      <h3 id="jsdoc-tags">7.3 JSDoc tags</h3>
      <p>
        Стиль Google позволяет подмножество JSDoc-тегов. Смотрите
        <a href="#appendices-jsdoc-tag-reference">?</a> для полного списка.
        Большинство тегов должны занимать свою собственную строку, с тегом в
        начале строки.
      </p>
      <p>Disallowed:</p>
      <pre><code class="language-js prettyprint badcode">/** * The "param" tag must occupy its own line and may not be combined. * @param {number} left @param {number} right */function add(left, right) { ... }</code></pre>
      <p>
        Простые теги, не требующие дополнительных данных (такие как
        <code>@private</code>, <code>@const</code>, <code>@final</code>,
        <code>@export</code>) могут быть объединены в одну строку вместе с
        дополнительным типом, если это необходимо.
      </p>
      <pre><code class="language-js prettyprint">/** * Place more complex annotations (like "implements" and "template") * on their own lines.  Multiple simple tags (like "export" and "final") * may be combined in one line. * @export @final * @implements {Iterable&lt;TYPE&gt;} * @template TYPE */class MyClass {  /**   * @param {!ObjType} obj Some object.   * @param {number=} num An optional number.   */  constructor(obj, num = 42) {    /** @private @const {!Array&lt;!ObjType|number&gt;} */    this.data_ = [obj, num];  }}</code></pre>
      <p>%321%</p>
      <p>
        Общую информацию об аннотировании типов в JavaScript см. в разделе
        <a
          href="https://github.com/google/closure-compiler/wiki/Annotating-JavaScript-for-the-Closure-Compiler"
          >Аннотирование JavaScript для компилятора типов закрытия</a
        >
        и
        <a
          href="https://github.com/google/closure-compiler/wiki/Types-in-the-Closure-Type-System"
          >Типы в системе типов закрытия</a
        >.
      </p>
      <h3 id="jsdoc-line-wrapping">7.4 Line wrapping</h3>
      <p>
        Тэги блоков в линейной обертке имеют отступы в четыре пробела. Обернутый
        текст описания может быть выровнен с описанием в предыдущих строках, но
        такое выравнивание по горизонтали не рекомендуется.
      </p>
      <pre><code class="language-js prettyprint">/** * Illustrates line wrapping for long param/return descriptions. * @param {string} foo This is a param with a description too long to fit in *     one line. * @return {number} This returns something that has a description too long to *     fit in one line. */exports.method = function(foo) {  return 5;};</code></pre>
      <p>
        Не делайте отступов при обёртывании описания <code>@desc</code> или
        <code>@просмотр файла</code>.
      </p>
      <h3 id="jsdoc-top-file-level-comments">7.5 Top/file-level comments</h3>
      <p>
        Файл может иметь обзор файлов верхнего уровня. Уведомление об авторском
        праве, информация об авторе и по умолчанию
        <a href="#jsdoc-visibility-annotations">уровень видимости</a> являются
        необязательными. Общий обзор файлов обычно рекомендуется, когда файл
        состоит из более чем одного определения класса. Комментарий верхнего
        уровня предназначен для того, чтобы сориентировать читателей, незнакомых
        с кодом, на то, что находится в этом файле. Если он присутствует, он
        может предоставить описание содержимого файла и информацию о любых
        зависимостях или совместимости. Обернутые строки не имеют отступов.
      </p>
      <p>Пример:</p>
      <pre><code class="language-js prettyprint">/** * @fileoverview Description of file, its uses and information * about its dependencies. * @package */</code></pre>
      <h3 id="jsdoc-class-comments">7.6 Class comments</h3>
      <p>
        Классы, интерфейсы и записи должны быть задокументированы с описанием и
        любыми параметрами шаблона, реализованными интерфейсами, видимостью или
        другими соответствующими тегами. Описание класса должно давать читателю
        достаточно информации, чтобы знать, как и когда использовать класс, а
        также любые дополнительные соображения, необходимые для корректного
        использования класса. Текстовые описания могут быть опущены на
        конструкторе. <code>@конструктор</code> и
        <code>@расширения</code> аннотации не используются с ключевым словом
        <code>класса</code>, если только класс не используется для объявления
        <code>@интерфейса</code> или не расширяет общий класс.
      </p>
      <pre><code class="language-js prettyprint">/** * A fancier event target that does cool things. * @implements {Iterable&lt;string&gt;} */class MyFancyTarget extends EventTarget {  /**   * @param {string} arg1 An argument that makes this more interesting.   * @param {!Array&lt;number&gt;} arg2 List of numbers to be processed.   */  constructor(arg1, arg2) {    // ...  }};/** * Records are also helpful. * @extends {Iterator&lt;TYPE&gt;} * @record * @template TYPE */class Listable {  /** @return {TYPE} The next item in line to be returned. */  next() {}}</code></pre>
      <h3 id="jsdoc-enum-and-typedef-comments">
        7.7 Enum and typedef comments
      </h3>
      <p>
        Все перечисления и typedefs должны быть задокументированы с помощью
        соответствующих тегов JSDoc (<code>@typedef</code> или
        <code>@enum</code>) в предыдущей строке. Публичные перечисления и
        typedefs также должны иметь описание. Отдельные элементы перечисления
        могут быть задокументированы JSDoc комментарием в предыдущей строке.
      </p>
      <pre><code class="language-js prettyprint">/** * A useful type union, which is reused often. * @typedef {!Bandersnatch|!BandersnatchType} */let CoolUnionType;/** * Types of bandersnatches. * @enum {string} */const BandersnatchType = {  /** This kind is really frumious. */  FRUMIOUS: 'frumious',  /** The less-frumious kind. */  MANXOME: 'manxome',};</code></pre>
      <p>
        Teypedefs полезны для определения типов коротких записей или псевдонимов
        для объединений, сложных функций или общих типов. Следует избегать
        типедов для типов записей с большим количеством полей, поскольку они не
        позволяют документировать отдельные поля, а также использовать шаблоны
        или рекурсивные ссылки. Для больших типов записей предпочитайте
        <code>@запись</code>.
      </p>
      <h3 id="jsdoc-method-and-function-comments">
        7.8 Method and function comments
      </h3>
      <p>
        В методах и именованных функциях должны документироваться типы
        параметров и возврата, за исключением случая одинаковой подписи
        <code>@override</code>s, где опущены все типы. Тип
        <code>этот тип</code> должен быть документирован при необходимости.
        Возвращаемый тип может быть опущен, если функция не имеет непустых
        выражений <code>return</code>.
      </p>
      <p>
        Описания метода, параметров и возвращаемых типов (но не типов) могут
        быть опущены, если они очевидны из остальной части метода&#8217;s JSDoc
        или из его подписи.
      </p>
      <p>
        Описания метода начинаются с глагольной фразы, описывающей, что делает
        метод. Эта фраза не является обязательным предложением, а написана в
        третьем лице, как будто перед ней подразумевается <q>Этот метод ...</q>.
      </p>
      <p>
        Если метод переопределяет метод суперкласса, он должен включать в себя
        примечание <code>@override</code>. Переопределенные методы наследуют все
        аннотации JSDoc от метода суперкласса (включая аннотации видимости) и
        должны быть опущены в переопределенном методе. Однако, если в аннотациях
        типа какой-либо тип уточнен, все <code>@param</code> и
        <code>@return</code> аннотации должны быть указаны явно.
      </p>
      <pre><code class="language-js prettyprint">/** A class that does something. */class SomeClass extends SomeBaseClass {  /**   * Operates on an instance of MyClass and returns something.   * @param {!MyClass} obj An object that for some reason needs detailed   *     explanation that spans multiple lines.   * @param {!OtherClass} obviousOtherClass   * @return {boolean} Whether something occurred.   */  someMethod(obj, obviousOtherClass) { ... }  /** @override */  overriddenMethod(param) { ... }}/** * Demonstrates how top-level functions follow the same rules.  This one * makes an array. * @param {TYPE} arg * @return {!Array&lt;TYPE&gt;} * @template TYPE */function makeArray(arg) { ... }</code></pre>
      <p>
        Если необходимо только документировать параметры и возвращаемые типы
        функции, можно дополнительно использовать встроенные JSDocs в сигнатуре
        функции. Эти встроенные JSDocs определяют типы возврата и параметров без
        тегов.
      </p>
      <pre><code class="language-js prettyprint">function /** string */ foo(/** number */ arg) {...}</code></pre>
      <p>
        Если вам нужны описания или теги, используйте один JSDoc комментарий
        выше метода. Например, методы, возвращающие значения, должны иметь тег
        <code>@return</code>.
      </p>
      <pre><code class="language-js prettyprint">class MyClass {  /**   * @param {number} arg   * @return {string}   */  bar(arg) {...}}</code></pre>
      <pre><code class="language-js prettyprint badcode">// Illegal inline JSDocs.class MyClass {  /** @return {string} */ foo() {...}}/** Function description. */ bar() {...}</code></pre>
      <p>
        В анонимных функциях аннотации, как правило, являются необязательными.
        Если автоматический вывод типа недостаточен или явная аннотация улучшает
        читабельность, то аннотируйте параметры и возвращаемые типы, как это
        делается:
      </p>
      <pre><code class="language-js prettyprint">promise.then(    /** @return {string} */    (/** !Array&lt;string&gt; */ items) =&gt; {      doSomethingWith(items);      return items[0];    });</code></pre>
      <p>
        Выражения типов функций см. в разделе
        <a href="#jsdoc-функции-типы">?</a>.
      </p>
      <h3 id="jsdoc-property-comments">7.9 Property comments</h3>
      <p>
        Типы свойств должны быть документированы. Описание может быть опущено
        для частных свойств, если имя и тип предоставляют достаточно
        документации для понимания кода.
      </p>
      <p>
        Публично экспортируемые константы комментируются так же, как и свойства.
      </p>
      <pre><code class="language-js prettyprint">/** My class. */class MyClass {  /** @param {string=} someString */  constructor(someString = 'default string') {    /** @private @const {string} */    this.someString_ = someString;    /** @private @const {!OtherType} */    this.someOtherThing_ = functionThatReturnsAThing();    /**     * Maximum number of things per pane.     * @type {number}     */    this.someProperty = 4;  }}/** * The number of times we'll try before giving up. * @const {number} */MyClass.RETRY_COUNT = 33;</code></pre>
      <h3 id="jsdoc-type-annotations">7.10 Type annotations</h3>
      <p>
        Аннотации типов находятся на тегах <code>@param</code>,
        <code>@return</code>, <code>@this</code>, и <code>@type</code>, и
        опционально на тегах <code>@const</code>, <code>@export</code>, и на
        любых тегах видимости. Аннотации типа, прикрепленные к тегам JSDoc,
        всегда должны быть заключены в фигурные скобки.
      </p>
      <h4 id="jsdoc-nullability">7.10.1 Nullability</h4>
      <p>
        Система типов определяет модификаторы <code>!</code> и
        <code>?</code> для ненулевых и нулевых соответственно. Эти модификаторы
        должны предшествовать типу.
      </p>
      <p>
        Модификаторы Nullability имеют различные требования к различным типам,
        которые делятся на две широкие категории:
      </p>
      <ol>
        <li>
          Type annotations for primitives (<code>string</code>,
          <code>number</code>, <code>boolean</code>, <code>symbol</code>,
          <code>undefined</code>, <code>null</code>) and literals (<code
            >{function(...): ...}</code
          >
          and <code>{{foo: string...}}</code>) are always non-nullable by
          default. Use the <code>?</code> modifier to make it nullable, but omit
          the redundant <code>!</code>.
        </li>
        <li>
          Reference types (generally, anything in <code>UpperCamelCase</code>,
          including <code>some.namespace.ReferenceType</code>) refer to a class,
          enum, record, or typedef defined elsewhere. Since these types may or
          may not be nullable, it is impossible to tell from the name alone
          whether it is nullable or not. Always use explicit <code>?</code> and
          <code>!</code> modifiers for these types to prevent ambiguity at use
          sites.
        </li>
      </ol>
      <p>Плохо:</p>
      <pre><code class="language-js prettyprint badcode">const /** MyObject */ myObject = null; // Non-primitive types must be annotated.const /** !number */ someNum = 5; // Primitives are non-nullable by default.const /** number? */ someNullableNum = null; // ? should precede the type.const /** !{foo: string, bar: number} */ record = ...; // Already non-nullable.const /** MyTypeDef */ def = ...; // Not sure if MyTypeDef is nullable.// Not sure if object (nullable), enum (non-nullable, unless otherwise// specified), or typedef (depends on definition).const /** SomeCamelCaseName */ n = ...;</code></pre>
      <p>Хорошо:</p>
      <pre><code class="language-js prettyprint">const /** ?MyObject */ myObject = null;const /** number */ someNum = 5;const /** ?number */ someNullableNum = null;const /** {foo: string, bar: number} */ record = ...;const /** !MyTypeDef */ def = ...;const /** ?SomeCamelCaseName */ n = ...;</code></pre>
      <h4 id="jsdoc-type-casts">7.10.2 Type Casts</h4>
      <p>
        В случаях, когда компилятор неточно определяет тип выражения, а функции
        утверждения в
        <a href="https://google.github.io/closure-library/api/goog.asserts.html"
          >goog.asserts</a
        >
        не могут это исправить, можно ужесточить тип, добавив комментарий к
        аннотации типа и заключив выражение в круглые скобки. Обратите внимание,
        что скобки необходимы.
      </p>
      <pre><code class="language-js prettyprint">/** @type {number} */ (x)</code></pre>
      <h4 id="jsdoc-template-parameter-types">
        7.10.3 Template Parameter Types
      </h4>
      <p>
        Всегда указывайте параметры шаблона. Таким образом, компилятор может
        сделать работу лучше, и читателю будет легче понять, что делает код.
      </p>
      <p>Плохо:</p>
      <pre><code class="language-js prettyprint badcode">const /** !Object */ users = {};const /** !Array */ books = [];const /** !Promise */ response = ...;</code></pre>
      <p>Хорошо:</p>
      <pre><code class="language-js prettyprint">const /** !Object&lt;string, !User&gt; */ users = {};const /** !Array&lt;string&gt; */ books = [];const /** !Promise&lt;!Response&gt; */ response = ...;const /** !Promise&lt;undefined&gt; */ thisPromiseReturnsNothingButParameterIsStillUseful = ...;const /** !Object&lt;string, *&gt; */ mapOfEverything = {};</code></pre>
      <p>Случаи, когда параметры шаблона не должны использоваться:</p>
      <ul>
        <li>
          <code>Object</code> is used for type hierarchy and not as map-like
          structure.
        </li>
      </ul>
      <h4 id="jsdoc-function-types">7.10.4 Function type expressions</h4>
      <p>
        <strong>Заметка по терминологии</strong>:
        <em>выражение типа функции</em> относится к аннотации типов функций с
        ключевым словом <code>function</code> в аннотации (см. примеры ниже).
      </p>
      <p>
        Там, где дано определение функции, не используйте выражение типа
        функции. Указывайте типы параметров и возвращаемых функций с помощью
        <code>@param</code> и <code>@return</code>, либо со строчными
        аннотациями (см. <a href="#jsdoc-метод-и-функция-комментарии">?</a>).
        Это включает анонимные функции и функции, определенные и назначенные
        консту (где функция jsdoc появляется над всем выражением назначения).
      </p>
      <p>
        Выражения типа функции необходимы, например, внутри
        <code>@typedef</code>, <code>@param</code> или <code>@return</code>.
        Используйте его также для переменных или свойств типа функции, если они
        не инициализируются сразу с определением функции.
      </p>
      <pre><code class="language-js prettyprint">  /** @private {function(string): string} */  this.idGenerator_ = googFunctions.identity;</code></pre>
      <p>
        При использовании выражения типа функции всегда указывайте тип возврата
        явно. В противном случае типом возврата по умолчанию является
        <q>неизвестный</q> (<code>?</code>), что приводит к странному и
        неожиданному поведению и редко является тем, что действительно
        желательно.
      </p>
      <p>Ошибка - ошибка типа, но предупреждение не выдается:</p>
      <pre><code class="language-js prettyprint badcode">/** @param {function()} generateNumber */function foo(generateNumber) {  const /** number */ x = generateNumber();  // No compile-time type error here.}foo(() =&gt; 'clearly not a number');</code></pre>
      <p>Хорошо:</p>
      <pre><code class="language-js prettyprint">/** * @param {function(): *} inputFunction1 Can return any type. * @param {function(): undefined} inputFunction2 Definitely doesn't return *      anything. * NOTE: the return type of `foo` itself is safely implied to be {undefined}. */function foo(inputFunction1, inputFunction2) {...}</code></pre>
      <h4 id="jsdoc-whitespace">7.10.5 Whitespace</h4>
      <p>
        В пределах типовой аннотации после каждой запятой или двоеточием
        требуется один пробел или разрыв строки. Дополнительные разрывы строк
        могут быть вставлены для улучшения читабельности или во избежание
        превышения предела столбца. Эти разрывы должны быть выбраны и снабжены
        отступами в соответствии с применимыми рекомендациями (например,
        <a href="#форматирование-обертка строк">?</a> и
        <a href="#форматирование-блок-индентирование">?</a>). Никакие другие
        пробельные символы не допускаются в аннотациях типов.
      </p>
      <p>Хорошо:</p>
      <pre><code class="language-js prettyprint">/** @type {function(string): number} *//** @type {{foo: number, bar: number}} *//** @type {number|string} *//** @type {!Object&lt;string, string&gt;} *//** @type {function(this: Object&lt;string, string&gt;, number): string} *//** * @type {function( *     !SuperDuperReallyReallyLongTypedefThatForcesTheLineBreak, *     !OtherVeryLongTypedef): string} *//** * @type {!SuperDuperReallyReallyLongTypedefThatForcesTheLineBreak| *     !OtherVeryLongTypedef} */</code></pre>
      <p>Плохо:</p>
      <pre><code class="language-js prettyprint badcode">// Only put a space after the colon/** @type {function(string) : number} */// Put spaces after colons and commas/** @type {{foo:number,bar:number}} */// No space in union types/** @type {number | string} */</code></pre>
      <h3 id="jsdoc-visibility-annotations">7.11 Visibility annotations</h3>
      <p>
        Аннотации видимости (<code>@приватный</code>, <code>@пакет</code>,
        <code>@защищенный</code>) могут быть указаны в
        <code>@блоке просмотра профиля</code>, или на любом экспортированном
        символе или свойстве. Не указывайте видимость для локальных переменных,
        будь то внутри функции или на верхнем уровне модуля. Все имена
        <code>@private</code> должны заканчиваться подчеркиванием.
      </p>
      <h2 id="policies">8 Policies</h2>
      <h3 id="policies-be-consistent">
        8.1 Issues unspecified by Google Style: Be Consistent!
      </h3>
      <p>
        Для любого стилевого вопроса, который окончательно не решен этой
        спецификацией, предпочитайте делать то, что уже делает другой код в том
        же файле. Если это не решает вопрос, подумайте об эмуляции других файлов
        в том же пакете.
      </p>
      <h3 id="policies-compiler-warnings">8.2 Compiler warnings</h3>
      <h4 id="policies-use-a-standard-warning-set">
        8.2.1 Use a standard warning set
      </h4>
      <p>
        Насколько это возможно, проекты должны использовать
        <code>--warning_level=VERBOSE</code>.
      </p>
      <h4 id="policies-how-to-handle-a-warning">
        8.2.2 How to handle a warning
      </h4>
      <p>
        Прежде чем что-либо делать, убедитесь, что вы точно понимаете, о чем
        говорит предупреждение. Если вы не уверены, почему предупреждение
        появляется, обратитесь за помощью .
      </p>
      <p>
        После того, как вы поймете предупреждение, попробуйте следующие решения
        по порядку:
      </p>
      <ol>
        <li>
          <strong>First, fix it or work around it.</strong> Make a strong
          attempt to actually address the warning, or find another way to
          accomplish the task that avoids the situation entirely.
        </li>
        <li>
          <strong>Otherwise, determine if it's a false alarm.</strong> If you
          are convinced that the warning is invalid and that the code is
          actually safe and correct, add a comment to convince the reader of
          this fact and apply the <code>@suppress</code> annotation.
        </li>
        <li>
          <strong>Otherwise, leave a TODO comment.</strong> This is a
          <strong>last resort</strong>. If you do this,
          <strong>do not suppress the warning.</strong> The warning should be
          visible until it can be taken care of properly.
        </li>
      </ol>
      <h4 id="policies-suppress-a-warning-at-the-narrowest-reasonable-scope">
        8.2.3 Suppress a warning at the narrowest reasonable scope
      </h4>
      <p>
        Предупреждения подавляются в самом узком разумном диапазоне, обычно это
        касается одной локальной переменной или очень маленького метода. Часто
        переменная или метод извлекается только по этой причине.
      </p>
      <p>Example</p>
      <pre><code class="language-js prettyprint">/** @suppress {uselessCode} Unrecognized 'use asm' declaration */function fn() {  'use asm';  return 0;}</code></pre>
      <p>
        Даже большое количество подавлений в классе все равно лучше, чем
        ослеплять весь класс этим типом предупреждений.
      </p>
      <h3 id="policies-deprecation">8.3 Deprecation</h3>
      <p>
        Пометьте устаревшие методы, классы или интерфейсы аннотациями
        <code>@deprecated</code>. Комментарий к устаревшим методам должен
        содержать простые и понятные указания для людей по исправлению их сайтов
        вызова.
      </p>
      <h3 id="policies-code-not-in-google-style">
        8.4 Code not in Google Style
      </h3>
      <p>
        Иногда в вашей кодовой базе встречаются файлы, которые не соответствуют
        стилю Google. Возможно, они появились в результате приобретения или были
        написаны до того, как Google Style занял позицию по какой-то проблеме,
        или могут быть в не-Google Style по любой другой причине.
      </p>
      <h4 id="policies-reformatting-existing-code">
        8.4.1 Reformatting existing code
      </h4>
      <p>
        При обновлении стиля существующего кода следуйте данным рекомендациям.
      </p>
      <ol>
        <li>
          It is not required to change all existing code to meet current style
          guidelines. Reformatting existing code is a trade-off between code
          churn and consistency. Style rules evolve over time and these kinds of
          tweaks to maintain compliance would create unnecessary churn. However,
          if significant changes are being made to a file it is expected that
          the file will be in Google Style.
        </li>
        <li>
          Be careful not to allow opportunistic style fixes to muddle the focus
          of a CL. If you find yourself making a lot of style changes that
          aren&#8217;t critical to the central focus of a CL, promote those
          changes to a separate CL.
        </li>
      </ol>
      <h4 id="policies-newly-added-code-use-google-style">
        8.4.2 Newly added code: use Google Style
      </h4>
      <p>
        В новых файлах используется Google Style, независимо от выбора стиля
        других файлов в том же пакете.
      </p>
      <p>
        При добавлении нового кода в файл, не входящий в Google Style,
        рекомендуется сначала переформатировать существующий код, с учетом
        рекомендации в <a href="#policies-reformatting-existing-code">?</a>.
      </p>
      <p>
        Если это переформатирование не выполняется, то новый код должен быть
        максимально согласован с существующим кодом в том же файле, но не должен
        нарушать руководство по стилю.
      </p>
      <h3 id="policies-local-style-rules">8.5 Local style rules</h3>
      <p>
        Группы и проекты могут принимать дополнительные правила в отношении
        стиля, помимо правил, содержащихся в настоящем документе, но должны
        согласиться с тем, что изменения в стиле очистки могут не
        соответствовать этим дополнительным правилам, и не должны блокировать
        такие изменения в стиле очистки в связи с нарушением любых
        дополнительных правил. Остерегайтесь чрезмерных правил, которые не
        служат никакой цели. Руководство по стилю не стремится определять стиль
        во всех возможных сценариях, и вы тоже не должны этого делать.
      </p>
      <h3 id="policies-generated-code-mostly-exempt">
        8.6 Generated code: mostly exempt
      </h3>
      <p>
        Исходный код, генерируемый в процессе сборки, не обязательно должен быть
        в Google Style. Однако, любые сгенерированные идентификаторы, на которые
        будут ссылаться из написанного от руки исходного кода, должны
        соответствовать требованиям к именованию. В качестве особого исключения
        такие идентификаторы могут содержать подчеркивания, что может помочь
        избежать конфликтов с написанными от руки идентификаторами.
      </p>
      <h2 id="appendices">9 Appendices</h2>
      <h3 id="appendices-jsdoc-tag-reference">9.1 JSDoc tag reference</h3>
      <p>
        JSDoc служит нескольким целям в JavaScript. Помимо того, что он
        используется для создания документации, он также используется для
        управления инструментарием. Наиболее известными являются аннотации типа
        Closure Compiler.
      </p>
      <h4 id="appendices-type-annotations">
        9.1.1 Type annotations and other Closure Compiler annotations
      </h4>
      <p>
        Документация для JSDoc, используемая компилятором, описана в
        <a
          href="https://github.com/google/closure-compiler/wiki/Annotating-JavaScript-for-the-Closure-Compiler"
          >Аннулирование JavaScript для компилятора закрытых типов</a
        >
        и
        <a
          href="https://github.com/google/closure-compiler/wiki/Types-in-the-Closure-Type-System"
          >Типы в системе типов закрытых типов</a
        >.
      </p>
      <h4 id="appendices-documentation-annotations">
        9.1.2 Documentation annotations
      </h4>
      <p>
        В дополнение к JSDoc, описанному в
        <a
          href="https://github.com/google/closure-compiler/wiki/Annotating-JavaScript-for-the-Closure-Compiler"
          >Аннулирование JavaScript для компилятора типов закрытия</a
        >
        следующие теги являются общими и хорошо поддерживаются различными
        инструментами генерации документации (такими как
        <a href="https://github.com/jleyba/js-dossier">JsDossier</a>) для чисто
        документационных целей.
      </p>
      <p>
        Вы также можете увидеть другие типы аннотаций JSDoc в коде сторонних
        разработчиков. Эти аннотации отображаются в виде
        <a href="http://code.google.com/p/jsdoc-toolkit/wiki/TagReference"
          >JSDoc Toolkit Tag Reference</a
        >, но не считаются частью действительного стиля Google.
      </p>
      <section class="zippy">
        <h5>
          9.1.2.1 <code>@author</code> or <code>@owner</code> -
          <em>Not recommended.</em>
        </h5>
        <p><strong>Не рекомендуется.</strong>.</p>
        <p>
          Синтаксис: <code>@автор username@google.com (Первый Последний)</code>.
        </p>
        <pre><code class="language-js prettyprint">/** * @fileoverview Utilities for handling textareas. * @author kuth@google.com (Uthur Pendragon) */</code></pre>
        <p>
          Документы автора файла или владельца теста, обычно используемые только
          в комментарии <code>@обзор файлов</code>. Тэг
          <code>@владелец</code> используется инструментальной панелью
          модульного теста для определения того, кому принадлежат результаты
          теста.
        </p>
      </section>
      <section class="zippy">
        <h5>9.1.2.2 <code>@bug</code></h5>
        <p>Синтаксис: <code>@тэг ошибки</code>.</p>
        <pre><code class="language-js prettyprint">/** @bug 1234567 */function testSomething() {  // &#8230;}/** * @bug 1234568 * @bug 1234569 */function testTwoBugs() {  // &#8230;}</code></pre>
        <p>
          Показывает, какие ошибки в регрессионных тестах данной функции теста.
        </p>
        <p>
          Несколько ошибок должны иметь свою строку <code>@bug</code>, чтобы
          поиск регрессионных тестов был максимально простым.
        </p>
      </section>
      <section class="zippy">
        <h5>9.1.2.3 <code>@code</code> - <em>Deprecated. Do not use.</em></h5>
        <p>
          <strong
            >Deprecated. Не использовать. Вместо этого используйте обратные
            ссылки Markdown backticks.</strong
          >.
        </p>
        <p>Синтаксис: <code>{@код ...}</code></p>
        <p>
          Исторически <code> BatchItem`</code> был написан как
          <code class="badcode">{@code BatchItem}</code>.
        </p>
        <pre><code class="language-js prettyprint">/** Processes pending `BatchItem` instances. */function processBatchItems() {}</code></pre>
        <p>
          Указывает, что термин в описании JSDoc является кодом, поэтому он
          может быть корректно отформатирован в сгенерированной документации.
        </p>
      </section>
      <section class="zippy">
        <h5>9.1.2.4 <code>@desc</code></h5>
        <p>Синтаксис: <code>@Описание сообщения</code>.</p>
        <pre><code class="language-js prettyprint">/** @desc Notifying a user that their account has been created. */exports.MSG_ACCOUNT_CREATED = goog.getMsg(    'Your account has been successfully created.');</code></pre>
      </section>
      <section class="zippy">
        <h5>9.1.2.5 <code>@link</code></h5>
        <p>Синтаксис: <code>{@ссылка ...}</code></p>
        <p>
          Этот тег используется для создания перекрестных ссылок в создаваемой
          документации.
        </p>
        <pre><code class="language-js prettyprint">/** Processes pending {@link BatchItem} instances. */function processBatchItems() {}</code></pre>
        <p>
          <strong>Историческое примечание:</strong> @link теги также
          используются для создания внешних ссылок в генерируемой документации.
          Для внешних ссылок всегда используйте синтаксис ссылки Markdown:
        </p>
        <pre><code class="language-js prettyprint">/** * This class implements a useful subset of the * [native Event interface](https://dom.spec.whatwg.org/#event). */class ApplicationEvent {}</code></pre>
      </section>
      <section class="zippy">
        <h5>9.1.2.6 <code>@see</code></h5>
        <p>Синтаксис: <code>@смотрите ссылку</code>.</p>
        <pre><code class="language-js prettyprint">/** * Adds a single item, recklessly. * @see #addSafely * @see goog.Collect * @see goog.RecklessAdder#add */</code></pre>
        <p>Ссылка на поиск другой функции или метода класса.</p>
      </section>
      <section class="zippy">
        <h5>9.1.2.7 <code>@supported</code></h5>
        <p>Синтаксис: <code>@поддерживаемое описание</code>.</p>
        <pre><code class="language-js prettyprint">/** * @fileoverview Event Manager * Provides an abstracted interface to the browsers' event systems. * @supported IE10+, Chrome, Safari */</code></pre>
        <p>
          Используется в обзоре файлов для указания того, какие браузеры
          поддерживаются файлом.
        </p>
      </section>
      <h4 id="appendices-framework-specific-annotations">
        9.1.3 Framework specific annotations
      </h4>
      <p>Следующие аннотации относятся к конкретному фреймворку.</p>
      <section class="zippy">
        <h5>9.1.3.1 <code>@ngInject</code> for Angular 1</h5>
      </section>
      <section class="zippy">
        <h5>9.1.3.2 <code>@polymerBehavior</code> for Polymer</h5>
        <p>
          <a href="https://github.com/google/closure-compiler/wiki/Polymer-Pass"
            >https://github.com/google/closure-compiler/wiki/Polymer-Pass</a
          >.
        </p>
      </section>
      <section class="zippy"></section>
      <h4 id="appendices-notes-about-standard-closure-compiler-annotations">
        9.1.4 Notes about standard Closure Compiler annotations
      </h4>
      <p>Раньше следующие теги были стандартными, но теперь они устарели.</p>
      <section class="zippy">
        <h5>9.1.4.1 <code>@expose</code> - <em>Deprecated. Do not use.</em></h5>
        <p>
          <strong
            >Deprecated. Не использовать. Используйте
            <code>@экспорт</code> и/или <code>@nocollapse</code> вместо.</strong
          >.
        </p>
      </section>
      <section class="zippy">
        <h5>
          9.1.4.2 <code>@inheritDoc</code> - <em>Deprecated. Do not use.</em>
        </h5>
        <p>
          <strong
            >Удаленный. Не использовать. Используйте
            <code>@переопределить</code> вместо.</strong
          >.
        </p>
      </section>
      <section class="zippy"></section>
      <section class="zippy"></section>
      <section class="zippy"></section>
      <section class="zippy"></section>
      <section class="zippy"></section>
      <section class="zippy"></section>
      <h3 id="appendices-commonly-misunderstood-style-rules">
        9.2 Commonly misunderstood style rules
      </h3>
      <p>
        Вот коллекция менее известных или часто непонятных фактов о Google Style
        для JavaScript. (Следующие утверждения верны; это не список
        <q>myths.</q>).
      </p>
      <ul>
        <li>
          Neither a copyright statement nor <code>@author</code> credit is
          required in a source file. (Neither is explicitly recommended,
          either.)
        </li>
        <li>
          There is no <q>hard and fast</q> rule governing how to order the
          members of a class (<a href="#features-classes">??</a>).
        </li>
        <li>
          Empty blocks can usually be represented concisely as <code>{}</code>,
          as detailed in (<a href="#formatting-empty-blocks">??</a>).
        </li>
        <li>
          The prime directive of line-wrapping is: prefer to break at a higher
          syntactic level (<a href="#formatting-where-to-break">??</a>).
        </li>
        <li>
          Non-ASCII characters are allowed in string literals, comments and
          JSDoc, and in fact are recommended when they make the code easier to
          read than the equivalent Unicode escape would (<a
            href="#non-ascii-characters"
            >??</a
          >).
        </li>
      </ul>
      <h3 id="appendices-style-related-tools">9.3 Style-related tools</h3>
      <p>
        Для поддержки различных аспектов Google Style существуют следующие
        инструменты.
      </p>
      <h4 id="appendices-tools-closure-compiler">9.3.1 Closure Compiler</h4>
      <p>
        Эта программа выполняет проверку типа и другие проверки, оптимизации и
        другие преобразования (такие как опускание кода с ECMAScript 6 на
        ECMAScript 5).
      </p>
      <h4 id="appendices-clang-format">9.3.2 <code>clang-format</code></h4>
      <p>
        Данная программа переформатирует исходный код JavaScript в Google Style,
        а также следует ряду ненужных, но часто повышающих читабельность практик
        форматирования. Вывод, полученный с помощью <code>кланг-формата</code>,
        соответствует руководству по стилю.
      </p>
      <p>
        <code>кланг-формат</code> не требуется. Авторам разрешено изменять его
        вывод, а рецензентам - запрашивать такие изменения; споры отработаны
        обычным образом. Тем не менее, поддеревья могут принять решение о
        локальном внедрении таких изменений.
      </p>
      <h4 id="appendices-closure-compiler-linter">
        9.3.3 Closure compiler linter
      </h4>
      <p>
        Данная программа проверяет на наличие различных ошибок и анти-шаблонов.
      </p>
      <h4 id="appendices-conformance-framework">9.3.4 Conformance framework</h4>
      <p>
        The JS Conformance Framework - это инструмент, входящий в состав Closure
        Compiler, который предоставляет разработчикам простое средство для
        задания набора дополнительных проверок, которые будут выполняться в их
        кодовой базе выше стандартных проверок. Проверки на соответствие могут,
        например, запретить доступ к определенному свойству, вызов определенной
        функции или недостающую информацию о типе (неизвестно).
      </p>
      <p>
        Эти правила обычно используются для обеспечения соблюдения критических
        ограничений (таких как определение глобусов, которые могут нарушить
        кодовую базу) и шаблонов безопасности (таких как использование
        <code>eval</code> или присвоение <code>innerHTML</code>), или более
        простых для улучшения качества кода.
      </p>
      <p>
        Для получения дополнительной информации обратитесь к официальной
        документации по
        <a
          href="https://github.com/google/closure-compiler/wiki/JS-Conformance-Framework"
          >JS Conformance Framework</a
        >.
      </p>
      <h3 id="appendices-legacy-exceptions">
        9.4 Exceptions for legacy platforms
      </h3>
      <h4 id="appendices-legacy-exceptions-overview">9.4.1 Overview</h4>
      <p>
        В этом разделе описаны исключения и дополнительные правила, которым
        необходимо следовать, когда современный синтаксис ECMAScript 6
        недоступен авторам кода. Исключения из рекомендуемого стиля необходимы в
        тех случаях, когда синтаксис ECMAScript 6 недоступен и описан здесь:
      </p>
      <ul>
        <li>Use of <code>var</code> declarations is allowed</li>
        <li>Use of <code>arguments</code> is allowed</li>
        <li>Optional parameters without default values are allowed</li>
      </ul>
      <h4 id="appendices-legacy-exceptions-var">9.4.2 Use <code>var</code></h4>
      <h5 id="appendices-legacy-exceptions-var-scope">
        9.4.2.1 <code>var</code> declarations are NOT block-scoped
      </h5>
      <p>
        <code>var</code> декларации скопированы до начала ближайшей к замыканию
        функции, скрипта или модуля, что может привести к неожиданному
        поведению, особенно при замыкании функций, которые ссылаются на
        <code>var</code> декларации внутри циклов. Следующий код приводит
        пример:
      </p>
      <pre><code class="language-js prettyprint badcode">for (var i = 0; i &lt; 3; ++i) {  var iteration = i;  setTimeout(function() { console.log(iteration); }, i*1000);}// logs 2, 2, 2 -- NOT 0, 1, 2// because `iteration` is function-scoped, not local to the loop.</code></pre>
      <h5 id="appendices-legacy-exceptions-var-declare">
        9.4.2.2 Declare variables as close as possible to first use
      </h5>
      <p>
        Несмотря на то, что <code>var</code> объявления скопированы в начало
        функции-перекрывателя, для удобочитаемости <code>var</code> объявления
        должны быть как можно ближе к их первому использованию. Однако не
        помещайте декларацию <code>var</code> внутри блока, если на эту
        переменную делается ссылка за пределами блока. Например:
      </p>
      <pre><code class="language-js prettyprint">function sillyFunction() {  var count = 0;  for (var x in y) {    // "count" could be declared here, but don't do that.    count++;  }  console.log(count + ' items in y');}</code></pre>
      <h5 id="appendices-legacy-exceptions-var-const">
        9.4.2.3 Use @const for constants variables
      </h5>
      <p>
        Для глобальных деклараций, в которых будет использоваться ключевое слово
        <code>const</code>, если оно доступно, аннотируйте вместо него
        декларацию <code>var</code> с помощью @const (это необязательно для
        локальных переменных).
      </p>
      <h4 id="appendices-legacy-exceptions-function">
        9.4.3 Do not use block scoped functions declarations
      </h4>
      <p>Делайте это <strong>not</strong>:</p>
      <pre><code class="language-js prettyprint badcode">if (x) {  function foo() {}}</code></pre>
      <p>
        Хотя большинство виртуальных машин на JavaScript, реализованных до
        ECMAScript 6, поддерживают функциональные декларации внутри блоков, они
        не были стандартизированы. Введения были несовместимы друг с другом и с
        теперь стандартным поведением ECMAScript 6 для объявлений функций в
        блоках. ECMAScript 5 и ранее допускал только объявления функций в списке
        корневых операторов скрипта или функции и явно запрещал их в блочных
        диапазонах в строгом режиме.
      </p>
      <p>
        Чтобы получить согласованное поведение, вместо этого используйте
        <code>var</code>, инициализированный выражением функции, для определения
        функции внутри блока:
      </p>
      <pre><code class="language-js prettyprint">if (x) {  var foo = function() {};}</code></pre>
      <h4 id="appendices-legacy-exceptions-goog-provide">
        9.4.4 Dependency management with <code>goog.provide</code>/<code
          >goog.require</code
        >
      </h4>
      <h5 id="appendices-legacy-exceptions-goog-provide-summary">
        9.4.4.1 Summary
      </h5>
      <p>
        <strong
          >WARNING: <code>goog.provide</code> управление зависимостями
          deprecated.</strong
        >
        Все новые файлы, даже в проектах, использующих
        <code>goog.provide</code> для старых файлов, должны использовать
        <a href="#source-file-structure"><code>goog.module</code></a
        >. Следующие правила предназначены только для уже существующих
        <code>goog.provide</code> файлов.
      </p>
      <ul>
        <li>
          Place all <code>goog.provide</code>s first, <code>goog.require</code>s
          second. Separate provides from requires with an empty line.
        </li>
        <li>Sort the entries alphabetically (uppercase first).</li>
        <li>
          Don't wrap <code>goog.provide</code> and
          <code>goog.require</code> statements. Exceed 80 columns if necessary.
        </li>
        <li>Only provide top-level symbols.</li>
      </ul>
      <p>
        <code>goog.provide</code> утверждения должны быть сгруппированы и
        помещены первыми. Все утверждения <code>goog.require</code> должны
        следовать. Оба списка должны быть разделены пустой строкой.
      </p>
      <p>
        Как и при импорте операторов на других языках, операторы
        <code>goog.provide</code> и <code>goog.require</code> должны быть
        написаны в одной строке, даже если они превышают ограничение длины
        строки в 80 столбцов.
      </p>
      <p>
        Строки должны быть отсортированы в алфавитном порядке с заглавными
        буквами:
      </p>
      <pre><code class="language-js prettyprint">goog.provide('namespace.MyClass');goog.provide('namespace.helperFoo');goog.require('an.extremelyLongNamespace.thatSomeoneThought.wouldBeNice.andNowItIsLonger.Than80Columns');goog.require('goog.dom');goog.require('goog.dom.TagName');goog.require('goog.dom.classes');goog.require('goog.dominoes');</code></pre>
      <p>
        Все члены, определенные в классе, должны быть в одном файле. В файле,
        содержащем несколько членов, определенных в одном и том же классе
        (например, перечисления, внутренние классы и т.д.), должны быть
        представлены только классы верхнего уровня.
      </p>
      <p>Сделайте это:</p>
      <pre><code class="language-js prettyprint">goog.provide('namespace.MyClass');</code></pre>
      <p>Не это:</p>
      <pre><code class="language-js prettyprint badcode">goog.provide('namespace.MyClass');goog.provide('namespace.MyClass.CONSTANT');goog.provide('namespace.MyClass.Enum');goog.provide('namespace.MyClass.InnerClass');goog.provide('namespace.MyClass.TypeDef');goog.provide('namespace.MyClass.staticMethod');</code></pre>
      <p>Могут также предоставляться члены в пространствах имен:</p>
      <pre><code class="language-js prettyprint">goog.provide('foo.bar');goog.provide('foo.bar.CONSTANT');goog.provide('foo.bar.method');</code></pre>
      <h5 id="appendices-legacy-exceptions-goog-scope">
        9.4.4.2 Aliasing with <code>goog.scope</code>
      </h5>
      <p>
        <strong>Предупреждение: <code>goog.scope</code> deprecated.</strong>
        Новые файлы не должны использовать <code>goog.scope</code> даже в
        проектах с существующим использованием <code>goog.scope</code>.
      </p>
      <p>
        <code>goog.scope</code> может быть использован для сокращения ссылок на
        символы, расположенные в пространстве имен в коде с использованием
        <code>goog.provide</code>/<code>goog.require</code> управление
        зависимостями.
      </p>
      <p>
        На каждый файл может быть добавлен только один вызов
        <code>goog.scope</code>. Всегда помещайте его в глобальную область
        видимости.
      </p>
      <p>
        Вызову <code>goog.scope(function()) {</code> должна предшествовать ровно
        одна пустая строка и следовать за любыми операторами
        <code>goog.provide</code>, <code>goog.require</code> или комментариями
        верхнего уровня. Призыв должен быть закрыт в последней строке файла.
        Добавьте <code>// goog.scope</code> к закрывающему выражению области
        видимости. Отделите комментарий от точки с запятой на два пробела.
      </p>
      <p>
        Аналогично пространствам имен C++ не отступайте под объявлениями
        <code>goog.scope</code>. Вместо этого продолжайте с колонки 0.
      </p>
      <p>
        Делайте псевдонимы только для имен, которые не будут переназначены
        другому объекту (например, большинство конструкторов, перечислений и
        пространств имен). Не делайте этого (см. ниже, как создать псевдоним для
        конструктора):
      </p>
      <pre><code class="language-js prettyprint badcode">goog.scope(function() {var Button = goog.ui.Button;Button = function() { ... };...</code></pre>
      <p>
        Имена должны быть такими же, как и последнее свойство глобального, на
        который они накладывают псевдонимы.
      </p>
      <pre><code class="language-js prettyprint">goog.provide('my.module.SomeType');goog.require('goog.dom');goog.require('goog.ui.Button');goog.scope(function() {var Button = goog.ui.Button;var dom = goog.dom;// Alias new types after the constructor declaration.my.module.SomeType = function() { ... };var SomeType = my.module.SomeType;// Declare methods on the prototype as usual:SomeType.prototype.findButton = function() {  // Button as aliased above.  this.button = new Button(dom.getElement('my-button'));};...});  // goog.scope</code></pre>
      <h5 id="appendices-legacy-exceptions-forward-declare">
        9.4.4.3 <code>goog.forwardDeclare</code>
      </h5>
      <p>
        Предпочтительно использовать <code>goog.requireType</code> вместо
        <code>goog.forwardDeclare</code> для разрыва круговых зависимостей между
        файлами в одной и той же библиотеке. В отличие от
        <code>goog.require</code>, оператор
        <code>goog.requireType</code> позволяет импортировать пространство имен
        до его определения.
      </p>
      <p>
        <code>goog.forwardDeclare</code> может по-прежнему использоваться в
        старом коде для разрыва круговых ссылок, выходящих за границы
        библиотеки, но более новый код должен быть структурирован, чтобы
        избежать этого.
      </p>
      <p>%435%</p>
    </div>
  </body>
</html>
